/**
 * ADead-BIB - Attention Compute Shader
 * =====================================
 * Author: Eddi AndreÃ© Salazar Matos
 * Made with love in Peru
 * 
 * Scaled Dot-Product Attention para Transformers.
 * Compile with: glslangValidator -V attention.comp -o attention.spv
 */

#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

/* Q, K, V matrices */
layout(set = 0, binding = 0) readonly buffer Query {
    float q[];
};

layout(set = 0, binding = 1) readonly buffer Key {
    float k[];
};

layout(set = 0, binding = 2) readonly buffer Value {
    float v[];
};

layout(set = 0, binding = 3) writeonly buffer Output {
    float out_data[];
};

/* Attention scores (temporal) */
layout(set = 0, binding = 4) buffer Scores {
    float scores[];
};

layout(push_constant) uniform Params {
    uint batch;
    uint heads;
    uint seq_len;
    uint head_dim;
    float scale;
} params;

shared float tile_q[16][16];
shared float tile_k[16][16];
shared float tile_scores[16][16];

void main() {
    uint batch_head = gl_WorkGroupID.z;
    uint batch_idx = batch_head / params.heads;
    uint head_idx = batch_head % params.heads;
    
    uint query_idx = gl_GlobalInvocationID.x;
    uint key_idx = gl_GlobalInvocationID.y;
    
    if (batch_idx >= params.batch || query_idx >= params.seq_len || key_idx >= params.seq_len) {
        return;
    }
    
    uint offset = (batch_idx * params.heads + head_idx) * params.seq_len * params.head_dim;
    
    /* Compute Q @ K^T */
    float dot = 0.0;
    
    uint num_tiles = (params.head_dim + 15) / 16;
    
    for (uint t = 0; t < num_tiles; t++) {
        uint tile_offset = t * 16;
        uint local_x = gl_LocalInvocationID.x;
        uint local_y = gl_LocalInvocationID.y;
        
        /* Load Q tile */
        uint q_idx = offset + query_idx * params.head_dim + tile_offset + local_y;
        if (query_idx < params.seq_len && tile_offset + local_y < params.head_dim) {
            tile_q[local_x][local_y] = q[q_idx];
        } else {
            tile_q[local_x][local_y] = 0.0;
        }
        
        /* Load K tile (transposed) */
        uint k_idx = offset + key_idx * params.head_dim + tile_offset + local_x;
        if (key_idx < params.seq_len && tile_offset + local_x < params.head_dim) {
            tile_k[local_x][local_y] = k[k_idx];
        } else {
            tile_k[local_x][local_y] = 0.0;
        }
        
        barrier();
        
        /* Compute partial dot product */
        for (uint i = 0; i < 16; i++) {
            dot += tile_q[local_x][i] * tile_k[i][local_y];
        }
        
        barrier();
    }
    
    /* Scale */
    dot *= params.scale;
    
    /* Store score */
    uint score_offset = batch_head * params.seq_len * params.seq_len;
    scores[score_offset + query_idx * params.seq_len + key_idx] = dot;
}
