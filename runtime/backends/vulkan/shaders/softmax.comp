/**
 * ADead-BIB - Softmax Compute Shader
 * ===================================
 * Author: Eddi AndreÃ© Salazar Matos
 * Made with love in Peru
 * 
 * Compile with: glslangValidator -V softmax.comp -o softmax.spv
 */

#version 450

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer Input {
    float input_data[];
};

layout(set = 0, binding = 1) writeonly buffer Output {
    float output_data[];
};

layout(push_constant) uniform Params {
    uint rows;
    uint cols;
} params;

shared float shared_max;
shared float shared_sum;

void main() {
    uint row = gl_WorkGroupID.x;
    uint tid = gl_LocalInvocationID.x;
    
    if (row >= params.rows) return;
    
    uint row_offset = row * params.cols;
    
    /* Step 1: Find max (reduction) */
    float local_max = -1e38;
    for (uint i = tid; i < params.cols; i += 256) {
        local_max = max(local_max, input_data[row_offset + i]);
    }
    
    /* Reduce within workgroup */
    shared float reduce_max[256];
    reduce_max[tid] = local_max;
    barrier();
    
    for (uint s = 128; s > 0; s >>= 1) {
        if (tid < s) {
            reduce_max[tid] = max(reduce_max[tid], reduce_max[tid + s]);
        }
        barrier();
    }
    
    if (tid == 0) {
        shared_max = reduce_max[0];
    }
    barrier();
    
    float max_val = shared_max;
    
    /* Step 2: Compute exp and sum */
    float local_sum = 0.0;
    for (uint i = tid; i < params.cols; i += 256) {
        float val = exp(input_data[row_offset + i] - max_val);
        output_data[row_offset + i] = val;
        local_sum += val;
    }
    
    /* Reduce sum */
    shared float reduce_sum[256];
    reduce_sum[tid] = local_sum;
    barrier();
    
    for (uint s = 128; s > 0; s >>= 1) {
        if (tid < s) {
            reduce_sum[tid] += reduce_sum[tid + s];
        }
        barrier();
    }
    
    if (tid == 0) {
        shared_sum = reduce_sum[0];
    }
    barrier();
    
    float sum_val = shared_sum;
    
    /* Step 3: Normalize */
    for (uint i = tid; i < params.cols; i += 256) {
        output_data[row_offset + i] /= sum_val;
    }
}
