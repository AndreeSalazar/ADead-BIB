/**
 * ADead-BIB - Matrix Multiplication Compute Shader
 * =================================================
 * Author: Eddi Andreé Salazar Matos
 * Made with love in Peru
 * 
 * Compile with: glslangValidator -V matmul.comp -o matmul.spv
 */

#version 450

/* Workgroup size optimizado para GPUs modernas */
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

/* Buffers de entrada/salida */
layout(set = 0, binding = 0) readonly buffer MatrixA {
    float a[];
};

layout(set = 0, binding = 1) readonly buffer MatrixB {
    float b[];
};

layout(set = 0, binding = 2) writeonly buffer MatrixC {
    float c[];
};

/* Push constants para dimensiones */
layout(push_constant) uniform Params {
    uint M;  /* Filas de A y C */
    uint N;  /* Columnas de B y C */
    uint K;  /* Columnas de A, Filas de B */
} params;

/* Shared memory para tiling */
shared float tile_a[16][16];
shared float tile_b[16][16];

void main() {
    uint row = gl_GlobalInvocationID.x;
    uint col = gl_GlobalInvocationID.y;
    
    /* Verificar límites */
    if (row >= params.M || col >= params.N) {
        return;
    }
    
    float sum = 0.0;
    
    /* Tiled matrix multiplication */
    uint num_tiles = (params.K + 15) / 16;
    
    for (uint t = 0; t < num_tiles; t++) {
        /* Cargar tiles a shared memory */
        uint tile_row = gl_LocalInvocationID.x;
        uint tile_col = gl_LocalInvocationID.y;
        
        uint a_col = t * 16 + tile_col;
        uint b_row = t * 16 + tile_row;
        
        if (row < params.M && a_col < params.K) {
            tile_a[tile_row][tile_col] = a[row * params.K + a_col];
        } else {
            tile_a[tile_row][tile_col] = 0.0;
        }
        
        if (b_row < params.K && col < params.N) {
            tile_b[tile_row][tile_col] = b[b_row * params.N + col];
        } else {
            tile_b[tile_row][tile_col] = 0.0;
        }
        
        /* Sincronizar workgroup */
        barrier();
        
        /* Multiplicar tiles */
        for (uint k = 0; k < 16; k++) {
            sum += tile_a[tile_row][k] * tile_b[k][tile_col];
        }
        
        /* Sincronizar antes del siguiente tile */
        barrier();
    }
    
    /* Escribir resultado */
    c[row * params.N + col] = sum;
}
