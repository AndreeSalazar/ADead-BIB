// ============================================================================
// FastOS Kernel - Entry Point
// ============================================================================
// GPU-First / Binary-First Operating System (64-bit)
// Stack: ADead-BIB + Rust + wgpu
//
// Author: Eddi Andre√© Salazar Matos üáµüá™
// ============================================================================

#![no_std]
#![no_main]

use bootloader_api::{entry_point, BootInfo};
use core::panic::PanicInfo;
use core::arch::asm;
use core::ptr;

// Colores RGB
const RED: u32 = 0xCD212A;      // Rojo peruano
const WHITE: u32 = 0xFFFFFF;
const BLACK: u32 = 0x000000;
const GREEN: u32 = 0x00FF00;
const YELLOW: u32 = 0xFFFF00;
const CYAN: u32 = 0x00FFFF;

entry_point!(kernel_main);

fn kernel_main(boot_info: &'static mut BootInfo) -> ! {
    // Obtener framebuffer
    if let Some(fb) = boot_info.framebuffer.as_mut() {
        let info = fb.info();
        let buffer = fb.buffer_mut();
        let width = info.width;
        let height = info.height;
        let stride = info.stride;
        let bpp = info.bytes_per_pixel;
        
        // Limpiar pantalla (negro)
        for y in 0..height {
            for x in 0..width {
                put_pixel(buffer, stride, bpp, x, y, BLACK);
            }
        }
        
        // Dibujar bandera de Per√∫
        let flag_w = width / 2;
        let flag_h = height / 4;
        let flag_x = (width - flag_w) / 2;
        let flag_y = 30;
        let stripe = flag_h / 3;
        
        // Franja roja superior
        for y in flag_y..(flag_y + stripe) {
            for x in flag_x..(flag_x + flag_w) {
                put_pixel(buffer, stride, bpp, x, y, RED);
            }
        }
        // Franja blanca
        for y in (flag_y + stripe)..(flag_y + stripe * 2) {
            for x in flag_x..(flag_x + flag_w) {
                put_pixel(buffer, stride, bpp, x, y, WHITE);
            }
        }
        // Franja roja inferior
        for y in (flag_y + stripe * 2)..(flag_y + flag_h) {
            for x in flag_x..(flag_x + flag_w) {
                put_pixel(buffer, stride, bpp, x, y, RED);
            }
        }
        
        // Texto
        let text_y = flag_y + flag_h + 30;
        draw_text(buffer, stride, bpp, width, "FastOS v0.1.0", text_y, GREEN);
        draw_text(buffer, stride, bpp, width, "GPU-First / Binary-First OS (64-bit)", text_y + 20, WHITE);
        draw_text(buffer, stride, bpp, width, "Stack: ADead-BIB + Rust + wgpu", text_y + 50, CYAN);
        draw_text(buffer, stride, bpp, width, "Author: Eddi Andree Salazar Matos", text_y + 80, YELLOW);
        draw_text(buffer, stride, bpp, width, "Email: eddi.salazar.dev@gmail.com", text_y + 100, WHITE);
        draw_text(buffer, stride, bpp, width, "Pais: Peru", text_y + 120, WHITE);
        draw_text(buffer, stride, bpp, width, "[OK] Kernel cargado!", text_y + 160, GREEN);
        draw_text(buffer, stride, bpp, width, "[OK] FastOS listo!", text_y + 180, GREEN);
    }
    
    loop { unsafe { asm!("hlt"); } }
}

#[inline]
fn put_pixel(buf: &mut [u8], stride: usize, bpp: usize, x: usize, y: usize, color: u32) {
    let off = y * stride * bpp + x * bpp;
    if off + 2 < buf.len() {
        buf[off] = (color & 0xFF) as u8;
        buf[off + 1] = ((color >> 8) & 0xFF) as u8;
        buf[off + 2] = ((color >> 16) & 0xFF) as u8;
    }
}

fn draw_text(buf: &mut [u8], stride: usize, bpp: usize, width: usize, text: &str, y: usize, color: u32) {
    let x = (width - text.len() * 8) / 2;
    let mut cx = x;
    for c in text.bytes() {
        draw_char(buf, stride, bpp, cx, y, c, color);
        cx += 9;
    }
}

fn draw_char(buf: &mut [u8], stride: usize, bpp: usize, x: usize, y: usize, c: u8, color: u32) {
    let bitmap = get_font(c);
    for (row, &bits) in bitmap.iter().enumerate() {
        for col in 0..8 {
            if bits & (0x80 >> col) != 0 {
                put_pixel(buf, stride, bpp, x + col, y + row, color);
            }
        }
    }
}

fn get_font(c: u8) -> [u8; 8] {
    match c {
        b'A' => [0x18,0x3C,0x66,0x7E,0x66,0x66,0x66,0x00],
        b'B' => [0x7C,0x66,0x7C,0x66,0x66,0x66,0x7C,0x00],
        b'C' => [0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00],
        b'D' => [0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00],
        b'E' => [0x7E,0x60,0x7C,0x60,0x60,0x60,0x7E,0x00],
        b'F' => [0x7E,0x60,0x7C,0x60,0x60,0x60,0x60,0x00],
        b'G' => [0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00],
        b'H' => [0x66,0x66,0x7E,0x66,0x66,0x66,0x66,0x00],
        b'I' => [0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00],
        b'K' => [0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00],
        b'L' => [0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00],
        b'M' => [0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x00],
        b'N' => [0x66,0x76,0x7E,0x6E,0x66,0x66,0x66,0x00],
        b'O' => [0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00],
        b'P' => [0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00],
        b'R' => [0x7C,0x66,0x66,0x7C,0x6C,0x66,0x66,0x00],
        b'S' => [0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00],
        b'T' => [0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00],
        b'U' => [0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00],
        b'V' => [0x66,0x66,0x66,0x66,0x3C,0x3C,0x18,0x00],
        b'W' => [0x63,0x63,0x6B,0x7F,0x77,0x63,0x63,0x00],
        b'a' => [0x00,0x00,0x3C,0x06,0x3E,0x66,0x3E,0x00],
        b'b' => [0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00],
        b'c' => [0x00,0x00,0x3C,0x60,0x60,0x60,0x3C,0x00],
        b'd' => [0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00],
        b'e' => [0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00],
        b'f' => [0x1C,0x30,0x7C,0x30,0x30,0x30,0x30,0x00],
        b'g' => [0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C],
        b'h' => [0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00],
        b'i' => [0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00],
        b'k' => [0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x00],
        b'l' => [0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00],
        b'm' => [0x00,0x00,0x76,0x7F,0x6B,0x63,0x63,0x00],
        b'n' => [0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00],
        b'o' => [0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00],
        b'p' => [0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60],
        b'r' => [0x00,0x00,0x7C,0x66,0x60,0x60,0x60,0x00],
        b's' => [0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00],
        b't' => [0x30,0x30,0x7C,0x30,0x30,0x30,0x1C,0x00],
        b'u' => [0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00],
        b'v' => [0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00],
        b'w' => [0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00],
        b'x' => [0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00],
        b'y' => [0x00,0x00,0x66,0x66,0x3E,0x06,0x3C,0x00],
        b'z' => [0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00],
        b'0' => [0x3C,0x66,0x6E,0x76,0x66,0x66,0x3C,0x00],
        b'1' => [0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00],
        b'6' => [0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00],
        b'4' => [0x0C,0x1C,0x3C,0x6C,0x7E,0x0C,0x0C,0x00],
        b' ' => [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
        b'.' => [0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00],
        b':' => [0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00],
        b'-' => [0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00],
        b'/' => [0x02,0x06,0x0C,0x18,0x30,0x60,0x40,0x00],
        b'@' => [0x3C,0x66,0x6E,0x6A,0x6E,0x60,0x3C,0x00],
        b'!' => [0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x00],
        b'(' => [0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00],
        b')' => [0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00],
        b'[' => [0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00],
        b']' => [0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00],
        b'+' => [0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00],
        _ => [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
    }
}

#[panic_handler]
fn panic(_: &PanicInfo) -> ! {
    loop { unsafe { asm!("hlt"); } }
}
