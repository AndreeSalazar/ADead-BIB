// ============================================================
// FastOS â€” Stage 2 Bootloader (ADead-BIB v3.3)
// ============================================================
// Loaded at 0x8000 by stage1. Runs in 16-bit real mode.
// 
// Simplified boot sequence:
//   1. Enable A20 line
//   2. Load kernel from disk to 0x100000 (via bounce buffer)
//   3. Set up GDT
//   4. Set up page tables (identity map first 4MB)
//   5. Enable protected mode + paging + long mode
//   6. Jump to kernel
//
// Memory map:
//   0x7C00   Stage1
//   0x7E00   Boot drive saved by stage1
//   0x8000   Stage2 (this)
//   0x9000   BootInfo struct
//   0x10000  Page tables (PML4, PDPT, PD)
//   0x20000  Kernel bounce buffer (chunk 1)
//   0x40000  Kernel bounce buffer (chunk 2)
//   0x60000  Kernel bounce buffer (chunk 3)
//   0x70000  GDT
//   0x100000 Kernel final location
// ============================================================

// ============================================================
// STEP 1: Enable A20 line (fast method)
// ============================================================
raw { 0xE4, 0x92 }       // in al, 0x92
raw { 0x0C, 0x02 }       // or al, 2
raw { 0x24, 0xFE }       // and al, 0xFE
raw { 0xE6, 0x92 }       // out 0x92, al

// ============================================================
// STEP 2: Load kernel from disk using INT 13h extended read
// ============================================================
// Reset disk first
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8A, 0x16, 0x00, 0x7E } // mov dl, [0x7E00]
int_call(0x13)

// Set up segments
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0x8E, 0xC0 }       // mov es, ax

// Build DAP (Disk Address Packet) at 0x7E10
// Chunk 1: 127 sectors from LBA 3 to 0x2000:0
raw { 0xC6, 0x06, 0x10, 0x7E, 0x10 } // size = 16
raw { 0xC6, 0x06, 0x11, 0x7E, 0x00 } // reserved = 0
raw { 0xC7, 0x06, 0x12, 0x7E, 0x7F, 0x00 } // sectors = 127
raw { 0xC7, 0x06, 0x14, 0x7E, 0x00, 0x00 } // offset = 0
raw { 0xC7, 0x06, 0x16, 0x7E, 0x00, 0x20 } // segment = 0x2000
raw { 0xC7, 0x06, 0x18, 0x7E, 0x03, 0x00 } // LBA low = 3
raw { 0xC7, 0x06, 0x1A, 0x7E, 0x00, 0x00 } // LBA high word 1
raw { 0xC7, 0x06, 0x1C, 0x7E, 0x00, 0x00 } // LBA high word 2
raw { 0xC7, 0x06, 0x1E, 0x7E, 0x00, 0x00 } // LBA high word 3

// Read chunk 1
raw { 0xB4, 0x42 }       // mov ah, 0x42
raw { 0x8A, 0x16, 0x00, 0x7E } // mov dl, [0x7E00]
raw { 0xBE, 0x10, 0x7E } // mov si, 0x7E10
int_call(0x13)

// Chunk 2: 127 sectors from LBA 130 to 0x4000:0
raw { 0xC7, 0x06, 0x16, 0x7E, 0x00, 0x40 } // segment = 0x4000
raw { 0xC7, 0x06, 0x18, 0x7E, 0x82, 0x00 } // LBA = 130
raw { 0xB4, 0x42 }
raw { 0x8A, 0x16, 0x00, 0x7E }
raw { 0xBE, 0x10, 0x7E }
int_call(0x13)

// Chunk 3: 127 sectors from LBA 257 to 0x6000:0
raw { 0xC7, 0x06, 0x16, 0x7E, 0x00, 0x60 } // segment = 0x6000
raw { 0xC7, 0x06, 0x18, 0x7E, 0x01, 0x01 } // LBA = 257
raw { 0xB4, 0x42 }
raw { 0x8A, 0x16, 0x00, 0x7E }
raw { 0xBE, 0x10, 0x7E }
int_call(0x13)

// ============================================================
// STEP 3: Write BootInfo at 0x9000 (VGA text mode fallback)
// ============================================================
// BootInfo structure (64 bytes):
//   0x00: magic (4 bytes) = 0x464F5321 ("!SOF")
//   0x04: _pad0 (4 bytes)
//   0x08: framebuffer_addr (8 bytes) = 0xB8000
//   0x10: framebuffer_width (4 bytes) = 80
//   0x14: framebuffer_height (4 bytes) = 25
//   0x18: framebuffer_bpp (4 bytes) = 4 (text mode indicator)
//   0x1C: framebuffer_pitch (4 bytes) = 160

// Zero out entire BootInfo first
raw { 0xB8, 0x00, 0x90 } // mov ax, 0x9000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xFF }       // xor di, di
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0xB9, 0x20, 0x00 } // mov cx, 32 (64 bytes / 2)
raw { 0xF3, 0xAB }       // rep stosw

// Reset segments
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax

// Magic: 0x464F5321
raw { 0xC7, 0x06, 0x00, 0x90, 0x21, 0x53 } // [0x9000] = 0x5321
raw { 0xC7, 0x06, 0x02, 0x90, 0x4F, 0x46 } // [0x9002] = 0x464F

// Framebuffer address: 0x00000000000B8000 (VGA text buffer, 8 bytes)
raw { 0xC7, 0x06, 0x08, 0x90, 0x00, 0x80 } // [0x9008] = 0x8000
raw { 0xC7, 0x06, 0x0A, 0x90, 0x0B, 0x00 } // [0x900A] = 0x000B
raw { 0xC7, 0x06, 0x0C, 0x90, 0x00, 0x00 } // [0x900C] = 0x0000
raw { 0xC7, 0x06, 0x0E, 0x90, 0x00, 0x00 } // [0x900E] = 0x0000

// Width: 80
raw { 0xC7, 0x06, 0x10, 0x90, 0x50, 0x00 } // [0x9010] = 80
raw { 0xC7, 0x06, 0x12, 0x90, 0x00, 0x00 }

// Height: 25
raw { 0xC7, 0x06, 0x14, 0x90, 0x19, 0x00 } // [0x9014] = 25
raw { 0xC7, 0x06, 0x16, 0x90, 0x00, 0x00 }

// BPP: 4 (text mode indicator - kernel will use VGA text fallback)
raw { 0xC7, 0x06, 0x18, 0x90, 0x04, 0x00 } // [0x9018] = 4
raw { 0xC7, 0x06, 0x1A, 0x90, 0x00, 0x00 }

// Pitch: 160 (80 * 2 bytes per char)
raw { 0xC7, 0x06, 0x1C, 0x90, 0xA0, 0x00 } // [0x901C] = 160
raw { 0xC7, 0x06, 0x1E, 0x90, 0x00, 0x00 }

// ============================================================
// STEP 4: Set up GDT at 0x70000
// ============================================================
raw { 0xB8, 0x00, 0x70 } // mov ax, 0x7000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xFF }       // xor di, di

// Null descriptor (8 bytes)
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0xAB }             // stosw
raw { 0xAB }
raw { 0xAB }
raw { 0xAB }

// Code32: 0x08 - 32-bit code, base=0, limit=4GB
raw { 0xB8, 0xFF, 0xFF } // limit low
raw { 0xAB }
raw { 0x31, 0xC0 }       // base low
raw { 0xAB }
raw { 0xB8, 0x00, 0x9A } // base mid + access (present, ring0, code, readable)
raw { 0xAB }
raw { 0xB8, 0xCF, 0x00 } // flags (4KB gran, 32-bit) + base high
raw { 0xAB }

// Data32: 0x10 - 32-bit data, base=0, limit=4GB
raw { 0xB8, 0xFF, 0xFF }
raw { 0xAB }
raw { 0x31, 0xC0 }
raw { 0xAB }
raw { 0xB8, 0x00, 0x92 } // access (present, ring0, data, writable)
raw { 0xAB }
raw { 0xB8, 0xCF, 0x00 }
raw { 0xAB }

// Code64: 0x18 - 64-bit code
raw { 0x31, 0xC0 }
raw { 0xAB }
raw { 0xAB }
raw { 0xB8, 0x00, 0x9A }
raw { 0xAB }
raw { 0xB8, 0xAF, 0x00 } // flags: L=1 (64-bit)
raw { 0xAB }

// Data64: 0x20 - 64-bit data
raw { 0x31, 0xC0 }
raw { 0xAB }
raw { 0xAB }
raw { 0xB8, 0x00, 0x92 }
raw { 0xAB }
raw { 0x31, 0xC0 }
raw { 0xAB }

// Set up GDTR at 0x7E30
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0xC7, 0x06, 0x30, 0x7E, 0x27, 0x00 } // limit = 39
raw { 0xC7, 0x06, 0x32, 0x7E, 0x00, 0x00 } // base low
raw { 0xC7, 0x06, 0x34, 0x7E, 0x07, 0x00 } // base high (0x70000)

// Load GDT
raw { 0x0F, 0x01, 0x16, 0x30, 0x7E } // lgdt [0x7E30]

// ============================================================
// STEP 5: Set up page tables at 0x10000
// ============================================================
// Zero 3 pages
raw { 0xB8, 0x00, 0x10 } // mov ax, 0x1000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xFF }       // xor di, di
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0xB9, 0x00, 0x18 } // mov cx, 0x1800
raw { 0xF3, 0xAB }       // rep stosw

// PML4[0] = 0x11003 (PDPT at 0x11000, present+writable)
raw { 0x26, 0xC7, 0x06, 0x00, 0x00, 0x03, 0x10 } // es:[0x0000] = 0x1003
raw { 0x26, 0xC7, 0x06, 0x02, 0x00, 0x01, 0x00 } // es:[0x0002] = 0x0001 -> 0x00011003

// PDPT[0] = 0x12003 (PD at 0x12000, present+writable)
raw { 0x26, 0xC7, 0x06, 0x00, 0x10, 0x03, 0x20 } // es:[0x1000] = 0x2003
raw { 0x26, 0xC7, 0x06, 0x02, 0x10, 0x01, 0x00 } // es:[0x1002] = 0x0001 -> 0x00012003

// PD[0] = 0x000083 (2MB page 0x000000-0x1FFFFF, present+writable+huge)
raw { 0x26, 0xC7, 0x06, 0x00, 0x20, 0x83, 0x00 } // es:[0x2000] = 0x0083
raw { 0x26, 0xC7, 0x06, 0x02, 0x20, 0x00, 0x00 } // es:[0x2002] = 0x0000 -> 0x00000083

// PD[1] = 0x200083 (2MB page 0x200000-0x3FFFFF for stack)
raw { 0x26, 0xC7, 0x06, 0x08, 0x20, 0x83, 0x00 } // es:[0x2008] = 0x0083
raw { 0x26, 0xC7, 0x06, 0x0A, 0x20, 0x20, 0x00 } // es:[0x200A] = 0x0020 -> 0x00200083

// ============================================================
// STEP 6: Enable PAE, load CR3, enable long mode
// ============================================================
// Enable PAE in CR4
raw { 0x0F, 0x20, 0xE0 } // mov eax, cr4
raw { 0x66, 0x0D, 0x20, 0x00, 0x00, 0x00 } // or eax, 0x20
raw { 0x0F, 0x22, 0xE0 } // mov cr4, eax

// Load PML4 into CR3
raw { 0x66, 0xB8, 0x00, 0x00, 0x01, 0x00 } // mov eax, 0x10000
raw { 0x0F, 0x22, 0xD8 } // mov cr3, eax

// Enable long mode in EFER MSR
raw { 0x66, 0xB9, 0x80, 0x00, 0x00, 0xC0 } // mov ecx, 0xC0000080
raw { 0x0F, 0x32 }       // rdmsr
raw { 0x66, 0x0D, 0x00, 0x01, 0x00, 0x00 } // or eax, 0x100 (LME)
raw { 0x0F, 0x30 }       // wrmsr

// ============================================================
// STEP 7: Write far jump pointers, enable paging, jump to PM
// ============================================================
// Far pointer for 32-bit entry at 0x7E20
// entry_32bit is at offset 0x1E6 = 0x81E6
raw { 0xC7, 0x06, 0x20, 0x7E, 0xE6, 0x81 } // offset = 0x81E6
raw { 0xC7, 0x06, 0x22, 0x7E, 0x00, 0x00 }
raw { 0xC7, 0x06, 0x24, 0x7E, 0x08, 0x00 } // selector 0x08

// Far pointer for 64-bit entry at 0x7E28
// entry_64bit is at offset 0x22A = 0x822A
raw { 0xC7, 0x06, 0x28, 0x7E, 0x2A, 0x82 } // offset = 0x822A
raw { 0xC7, 0x06, 0x2A, 0x7E, 0x00, 0x00 }
raw { 0xC7, 0x06, 0x2C, 0x7E, 0x18, 0x00 } // selector 0x18

// Enable paging + protected mode
raw { 0x0F, 0x20, 0xC0 } // mov eax, cr0
raw { 0x66, 0x0D, 0x01, 0x00, 0x00, 0x80 } // or eax, 0x80000001
raw { 0x0F, 0x22, 0xC0 } // mov cr0, eax

// Far jump to 32-bit code
raw { 0x66, 0xFF, 0x2E, 0x20, 0x7E } // jmp far [0x7E20]

// ============================================================
// 32-BIT PROTECTED MODE ENTRY
// ============================================================
label entry_32bit:
// Set data segments
raw { 0xB8, 0x10, 0x00, 0x00, 0x00 } // mov eax, 0x10
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x8E, 0xD0 }       // mov ss, ax

// Copy kernel from bounce buffers to 0x100000
// Chunk 1: 0x20000 -> 0x100000
raw { 0xBE, 0x00, 0x00, 0x02, 0x00 } // mov esi, 0x20000
raw { 0xBF, 0x00, 0x00, 0x10, 0x00 } // mov edi, 0x100000
raw { 0xB9, 0x80, 0x3F, 0x00, 0x00 } // mov ecx, 0x3F80 (127*512/4)
raw { 0xF3, 0xA5 }       // rep movsd

// Chunk 2: 0x40000 -> 0x10FE00
raw { 0xBE, 0x00, 0x00, 0x04, 0x00 }
raw { 0xBF, 0x00, 0xFE, 0x10, 0x00 }
raw { 0xB9, 0x80, 0x3F, 0x00, 0x00 }
raw { 0xF3, 0xA5 }

// Chunk 3: 0x60000 -> 0x11FC00
raw { 0xBE, 0x00, 0x00, 0x06, 0x00 }
raw { 0xBF, 0x00, 0xFC, 0x11, 0x00 }
raw { 0xB9, 0x80, 0x3F, 0x00, 0x00 }
raw { 0xF3, 0xA5 }

// Far jump to 64-bit code
raw { 0xFF, 0x2D, 0x28, 0x7E, 0x00, 0x00 } // jmp far [0x7E28]

// ============================================================
// 64-BIT LONG MODE ENTRY
// ============================================================
label entry_64bit:
// Set data segments
raw { 0x66, 0xB8, 0x20, 0x00 } // mov ax, 0x20
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x8E, 0xD0 }       // mov ss, ax

// Set up stack at 0x80000 (within first 2MB, definitely mapped)
raw { 0x48, 0xBC, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 }

// Jump to kernel at 0x100000
raw { 0x48, 0xB8, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00 }
raw { 0xFF, 0xE0 }       // jmp rax

// Halt loop
label halt:
cli
hlt
jmp halt
