// ============================================================
// FastOS — Stage 2: Boot Mode Switch (ADead-BIB)
// ============================================================
// Loaded at 0x8000 by stage1. Runs in 16-bit real mode.
//
// Full boot sequence:
//   1. Enable A20 line (fast method + keyboard controller)
//   2. Get E820 memory map
//   3. Set VBE video mode (1024x768x32) via INT 10h
//   4. Load kernel binary from disk to 0x100000
//   5. Write BootInfo struct at 0x9000
//   6. Set up GDT (code32, data32, code64, data64)
//   7. Switch to Protected Mode (32-bit)
//   8. Set up identity-mapped page tables (PML4→PDPT→PD)
//   9. Enable PAE + Long Mode via MSR
//  10. Switch to Long Mode (64-bit)
//  11. Jump to kernel_main at 0x100000
//
// Memory map:
//   0x7C00       Stage1 (boot sector)
//   0x7E00       Boot drive number (saved by stage1)
//   0x8000       Stage2 (this file)
//   0x9000       BootInfo struct (64 bytes)
//   0x9100       E820 memory map entries
//   0x10000      Page tables (PML4, PDPT, PD) — 3 pages
//   0x70000      Temporary GDT
//   0x100000     Kernel binary (loaded from disk)
//
// ADead-BIB generates ALL bytes. Zero ASM.
// ============================================================

// ============================================================
// STEP 1: Enable A20 line
// ============================================================
// Fast A20 method: port 0x92
raw { 0xE4, 0x92 }       // in al, 0x92
raw { 0x0C, 0x02 }       // or al, 2
raw { 0x24, 0xFE }       // and al, 0xFE (don't reset)
raw { 0xE6, 0x92 }       // out 0x92, al

// Keyboard controller A20 fallback
raw { 0xE4, 0x64 }       // in al, 0x64
raw { 0xA8, 0x02 }       // test al, 2
raw { 0x75, 0xFB }       // jnz -5 (wait for input buffer empty)
raw { 0xB0, 0xD1 }       // mov al, 0xD1 (write output port)
raw { 0xE6, 0x64 }       // out 0x64, al
raw { 0xE4, 0x64 }       // in al, 0x64
raw { 0xA8, 0x02 }       // test al, 2
raw { 0x75, 0xFB }       // jnz -5
raw { 0xB0, 0xDF }       // mov al, 0xDF (A20 enable)
raw { 0xE6, 0x60 }       // out 0x60, al

// ============================================================
// STEP 2: Get E820 memory map → store at 0x9100
// ============================================================
// Set ES:DI = 0x0000:0x9100
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0xBF, 0x00, 0x91 } // mov di, 0x9100
raw { 0x31, 0xDB }       // xor ebx, ebx (continuation = 0)
raw { 0x31, 0xF6 }       // xor si, si (entry count)

// e820_loop:
raw { 0x66, 0xB8, 0x20, 0xE8, 0x00, 0x00 } // mov eax, 0x0000E820
// mov ecx, 24
raw { 0x66, 0xB9, 0x18, 0x00, 0x00, 0x00 } // mov ecx, 24
// mov edx, 0x534D4150 ('SMAP')
raw { 0x66, 0xBA, 0x50, 0x41, 0x4D, 0x53 } // mov edx, 0x534D4150
// int 0x15
int_call(0x15)

// jc e820_done (carry = error or end)
raw { 0x72, 0x19 }       // jc +25 (skip to e820_done)

// Increment count
raw { 0x46 }              // inc si

// Advance DI by 24 bytes
raw { 0x83, 0xC7, 0x18 } // add di, 24

// Check if ebx = 0 (last entry)
raw { 0x66, 0x09, 0xDB } // or ebx, ebx
raw { 0x74, 0x0E }       // jz e820_done (+14)

// Loop: mov eax, 0xE820; mov ecx, 24; mov edx, SMAP; int 15h
raw { 0x66, 0xB8, 0x20, 0xE8, 0x00, 0x00 }
raw { 0x66, 0xB9, 0x18, 0x00, 0x00, 0x00 }
raw { 0x66, 0xBA, 0x50, 0x41, 0x4D, 0x53 }
int_call(0x15)
raw { 0x73, 0xE5 }       // jnc back to inc si (-27)

// e820_done:
// Store entry count at 0x9000 + 36 (memory_map_count field)
// We'll write the full BootInfo later. Save SI for now.
raw { 0x89, 0x36, 0x50, 0x91 } // mov [0x9150], si (temp save count)

// ============================================================
// STEP 3: Set VBE video mode 1024x768x32
// ============================================================
// Try VBE mode 0x118 (1024x768x32)
// AX = 0x4F02 (set VBE mode)
// BX = 0x4118 (mode 0x118 + linear framebuffer bit 14)
raw { 0xB8, 0x02, 0x4F } // mov ax, 0x4F02
raw { 0xBB, 0x18, 0x41 } // mov bx, 0x4118
int_call(0x10)

// Check if VBE succeeded (AL = 0x4F)
raw { 0x3C, 0x4F }       // cmp al, 0x4F
raw { 0x74, 0x0E }       // je vbe_ok (+14)

// VBE failed — try mode 0x115 (800x600x32)
raw { 0xB8, 0x02, 0x4F } // mov ax, 0x4F02
raw { 0xBB, 0x15, 0x41 } // mov bx, 0x4115
int_call(0x10)
raw { 0x3C, 0x4F }       // cmp al, 0x4F
raw { 0x74, 0x02 }       // je vbe_ok (+2)

// Both failed — continue anyway (kernel will use VGA text fallback)
raw { 0xEB, 0x00 }       // jmp vbe_ok (nop jump, fall through)

// vbe_ok:
// Get VBE mode info to find framebuffer address
// AX = 0x4F01, CX = mode, ES:DI = buffer at 0x9200
raw { 0xBF, 0x00, 0x92 } // mov di, 0x9200
raw { 0xB8, 0x01, 0x4F } // mov ax, 0x4F01
raw { 0xB9, 0x18, 0x01 } // mov cx, 0x0118
int_call(0x10)

// Read framebuffer address from VBE mode info (offset 40 = 0x28)
// PhysBasePtr is at ES:DI+40 (dword)
// We'll read it later when writing BootInfo

// ============================================================
// STEP 4: Load kernel from disk to 0x100000
// ============================================================
// We can't load directly above 1MB in real mode (A20 is on but
// segments can only reach ~1MB). Use a bounce buffer at 0x20000
// and copy via unreal mode or load in chunks.
//
// Strategy: Load kernel sectors to 0x20000, then use
// protected mode copy to move to 0x100000.
//
// Load 128 sectors (64KB) from sector 18 (after stage1+stage2)
// to 0x2000:0x0000 = 0x20000

// Reset disk
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8A, 0x16, 0x00, 0x7E } // mov dl, [0x7E00] (boot drive)
int_call(0x13)

// Set ES = 0x2000 (target = 0x20000)
raw { 0xB8, 0x00, 0x20 } // mov ax, 0x2000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xDB }       // xor bx, bx (offset 0)

// Use INT 13h extended read (LBA) if available
// AH=0x42, DL=drive, DS:SI=disk address packet
// Disk Address Packet at 0x7E10:
//   byte  size = 16
//   byte  reserved = 0
//   word  sectors = 128
//   dword buffer = 0x2000:0x0000
//   qword LBA = 17 (sector 18, 0-indexed = 17)

// Build DAP at 0x7E10
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax

raw { 0xC6, 0x06, 0x10, 0x7E, 0x10 } // mov byte [0x7E10], 16 (packet size)
raw { 0xC6, 0x06, 0x11, 0x7E, 0x00 } // mov byte [0x7E11], 0 (reserved)
raw { 0xC7, 0x06, 0x12, 0x7E, 0x80, 0x00 } // mov word [0x7E12], 128 (sectors)
raw { 0xC7, 0x06, 0x14, 0x7E, 0x00, 0x00 } // mov word [0x7E14], 0x0000 (offset)
raw { 0xC7, 0x06, 0x16, 0x7E, 0x00, 0x20 } // mov word [0x7E16], 0x2000 (segment)
raw { 0xC7, 0x06, 0x18, 0x7E, 0x11, 0x00 } // mov word [0x7E18], 17 (LBA low)
raw { 0xC7, 0x06, 0x1A, 0x7E, 0x00, 0x00 } // mov word [0x7E1A], 0 (LBA high low)
raw { 0xC7, 0x06, 0x1C, 0x7E, 0x00, 0x00 } // mov word [0x7E1C], 0
raw { 0xC7, 0x06, 0x1E, 0x7E, 0x00, 0x00 } // mov word [0x7E1E], 0

// INT 13h AH=42h extended read
raw { 0xB4, 0x42 }       // mov ah, 0x42
raw { 0x8A, 0x16, 0x00, 0x7E } // mov dl, [0x7E00]
raw { 0xBE, 0x10, 0x7E } // mov si, 0x7E10
int_call(0x13)

// If carry set, try CHS fallback (read fewer sectors)
raw { 0x73, 0x12 }       // jnc load_ok (+18)

// CHS fallback: read 64 sectors from CHS (0,1,1) = sector 18
raw { 0xB8, 0x00, 0x20 } // mov ax, 0x2000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xDB }       // xor bx, bx
raw { 0xB4, 0x02 }       // mov ah, 0x02 (read)
raw { 0xB0, 0x40 }       // mov al, 64 (sectors)
raw { 0xB5, 0x00 }       // mov ch, 0 (cylinder)
raw { 0xB1, 0x12 }       // mov cl, 18 (sector, 1-based)
raw { 0xB6, 0x01 }       // mov dh, 1 (head)
raw { 0x8A, 0x16, 0x00, 0x7E } // mov dl, [0x7E00]
int_call(0x13)

// load_ok:

// ============================================================
// STEP 5: Write BootInfo at 0x9000
// ============================================================
// BootInfo struct (64 bytes):
//   u32 magic          = 0x464F5321 ("FOS!")
//   u64 fb_addr        = from VBE mode info
//   u32 fb_width       = 1024
//   u32 fb_height      = 768
//   u32 fb_bpp         = 32
//   u32 fb_pitch       = from VBE mode info
//   u64 mmap_addr      = 0x9100
//   u32 mmap_count     = from E820
//   u8[20] reserved    = 0

// Zero out BootInfo area
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0xBF, 0x00, 0x90 } // mov di, 0x9000
raw { 0xB9, 0x20, 0x00 } // mov cx, 32 (32 words = 64 bytes)
raw { 0xF3, 0xAB }       // rep stosw

// Magic: 0x464F5321 at [0x9000]
raw { 0xC7, 0x06, 0x00, 0x90, 0x21, 0x53 } // mov word [0x9000], 0x5321
raw { 0xC7, 0x06, 0x02, 0x90, 0x4F, 0x46 } // mov word [0x9002], 0x464F

// Framebuffer address: read from VBE mode info at 0x9200+40
// PhysBasePtr is at offset 40 (0x28) in mode info block
raw { 0xA1, 0x28, 0x92 } // mov ax, [0x9228]
raw { 0xA3, 0x04, 0x90 } // mov [0x9004], ax
raw { 0x8B, 0x06, 0x2A, 0x92 } // mov ax, [0x922A]
raw { 0xA3, 0x06, 0x90 } // mov [0x9006], ax
// High dword of fb_addr = 0
raw { 0xC7, 0x06, 0x08, 0x90, 0x00, 0x00 } // mov word [0x9008], 0
raw { 0xC7, 0x06, 0x0A, 0x90, 0x00, 0x00 } // mov word [0x900A], 0

// Width: read from VBE mode info offset 18 (0x12) = XResolution
raw { 0x8B, 0x06, 0x12, 0x92 } // mov ax, [0x9212]
raw { 0xA3, 0x0C, 0x90 } // mov [0x900C], ax
raw { 0xC7, 0x06, 0x0E, 0x90, 0x00, 0x00 } // high word = 0

// Height: read from VBE mode info offset 20 (0x14) = YResolution
raw { 0x8B, 0x06, 0x14, 0x92 } // mov ax, [0x9214]
raw { 0xA3, 0x10, 0x90 } // mov [0x9010], ax
raw { 0xC7, 0x06, 0x12, 0x90, 0x00, 0x00 } // high word = 0

// BPP: 32
raw { 0xC7, 0x06, 0x14, 0x90, 0x20, 0x00 } // mov word [0x9014], 32
raw { 0xC7, 0x06, 0x16, 0x90, 0x00, 0x00 }

// Pitch: read from VBE mode info offset 16 (0x10) = BytesPerScanLine
raw { 0x8B, 0x06, 0x10, 0x92 } // mov ax, [0x9210]
raw { 0xA3, 0x18, 0x90 } // mov [0x9018], ax
raw { 0xC7, 0x06, 0x1A, 0x90, 0x00, 0x00 }

// Memory map address: 0x9100
raw { 0xC7, 0x06, 0x1C, 0x90, 0x00, 0x91 } // mov word [0x901C], 0x9100
raw { 0xC7, 0x06, 0x1E, 0x90, 0x00, 0x00 }
raw { 0xC7, 0x06, 0x20, 0x90, 0x00, 0x00 }
raw { 0xC7, 0x06, 0x22, 0x90, 0x00, 0x00 }

// Memory map count: from saved value at 0x9150
raw { 0x8B, 0x06, 0x50, 0x91 } // mov ax, [0x9150]
raw { 0xA3, 0x24, 0x90 } // mov [0x9024], ax
raw { 0xC7, 0x06, 0x26, 0x90, 0x00, 0x00 }

// ============================================================
// STEP 6: Set up GDT at 0x70000
// ============================================================
// GDT entries (8 bytes each):
//   0x00: Null descriptor
//   0x08: Code32 (32-bit code, base=0, limit=4GB, ring 0)
//   0x10: Data32 (32-bit data, base=0, limit=4GB, ring 0)
//   0x18: Code64 (64-bit code, base=0, limit=0, ring 0)
//   0x20: Data64 (64-bit data, base=0, limit=0, ring 0)

// Null descriptor at 0x70000
// Set ES = 0x7000
raw { 0xB8, 0x00, 0x70 } // mov ax, 0x7000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xFF }       // xor di, di

// Null descriptor (8 bytes of 0)
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 } // mov word es:[di], 0
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }

// Code32 descriptor at offset 0x08: base=0, limit=0xFFFFF, 32-bit code
// Bytes: FF FF 00 00 00 9A CF 00
raw { 0x26, 0xC7, 0x05, 0xFF, 0xFF } // limit low
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 } // base low
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x9A } // base mid + access (code, readable, ring 0)
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0xCF, 0x00 } // flags (4KB gran, 32-bit) + limit high + base high
raw { 0x83, 0xC7, 0x02 }

// Data32 descriptor at offset 0x10: base=0, limit=0xFFFFF, 32-bit data
// Bytes: FF FF 00 00 00 92 CF 00
raw { 0x26, 0xC7, 0x05, 0xFF, 0xFF }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x92 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0xCF, 0x00 }
raw { 0x83, 0xC7, 0x02 }

// Code64 descriptor at offset 0x18: 64-bit code segment
// Bytes: 00 00 00 00 00 9A 20 00
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x9A } // access: code, readable, ring 0
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x20, 0x00 } // flags: L=1 (long mode), D=0
raw { 0x83, 0xC7, 0x02 }

// Data64 descriptor at offset 0x20: 64-bit data segment
// Bytes: 00 00 00 00 00 92 00 00
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x92 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }

// GDT pointer at 0x70028 (after GDT entries)
// limit = 5*8 - 1 = 39 = 0x27
// base = 0x00070000
raw { 0x26, 0xC7, 0x05, 0x27, 0x00 } // limit
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 } // base low (0x0000)
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x07, 0x00 } // base high (0x0007)
raw { 0x83, 0xC7, 0x02 }

// Restore DS = 0
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax

// ============================================================
// STEP 7: Disable interrupts and load GDT
// ============================================================
cli

// lgdt [0x70028] — GDT pointer is at 0x7000:0x0028
// In real mode with DS=0, we need to address 0x70028
// Use: lgdt [ds:addr] but addr must be < 64KB
// Solution: set DS = 0x7000 temporarily
raw { 0xB8, 0x00, 0x70 } // mov ax, 0x7000
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0x0F, 0x01, 0x16, 0x28, 0x00 } // lgdt [0x0028]

// Restore DS = 0
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax

// ============================================================
// STEP 8: Set up page tables at 0x10000
// ============================================================
// PML4 at 0x10000, PDPT at 0x11000, PD at 0x12000
// Identity map first 2GB using 2MB pages

// Clear page table area (3 pages = 12KB = 6144 words)
raw { 0xB8, 0x00, 0x10 } // mov ax, 0x1000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xFF }       // xor di, di
raw { 0xB9, 0x00, 0x18 } // mov cx, 0x1800 (6144 words = 3 pages)
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0xF3, 0xAB }       // rep stosw

// PML4[0] → PDPT at 0x11000 (present + writable)
// Write 0x00011003 at 0x10000
raw { 0xB8, 0x00, 0x10 } // mov ax, 0x1000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xFF }       // xor di, di
// PML4[0] = 0x00011003
raw { 0x26, 0x66, 0xC7, 0x05, 0x03, 0x10, 0x01, 0x00 } // mov dword es:[di], 0x00011003

// PDPT[0] → PD at 0x12000 (present + writable)
// Write 0x00012003 at 0x11000 (ES:0x1000)
raw { 0xBF, 0x00, 0x10 } // mov di, 0x1000
raw { 0x26, 0x66, 0xC7, 0x05, 0x03, 0x20, 0x01, 0x00 } // mov dword es:[di], 0x00012003

// PD entries: 512 entries × 2MB = 1GB identity mapped
// Each entry: addr | 0x83 (present + writable + page size = 2MB)
// PD starts at 0x12000 (ES:0x2000)
raw { 0xBF, 0x00, 0x20 } // mov di, 0x2000
raw { 0x66, 0x31, 0xC0 } // xor eax, eax (start address = 0)
raw { 0x66, 0x0D, 0x83, 0x00, 0x00, 0x00 } // or eax, 0x83 (present+write+PS)
raw { 0xB9, 0x00, 0x02 } // mov cx, 512

// pd_loop:
raw { 0x26, 0x66, 0x89, 0x05 } // mov dword es:[di], eax
raw { 0x83, 0xC7, 0x04 }       // add di, 4
raw { 0x26, 0x66, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x00 } // mov dword es:[di], 0 (high)
raw { 0x83, 0xC7, 0x04 }       // add di, 4
raw { 0x66, 0x05, 0x00, 0x00, 0x20, 0x00 } // add eax, 0x200000 (2MB)
raw { 0x49 }                     // dec cx
raw { 0x75, 0xE6 }               // jnz pd_loop (-26)

// ============================================================
// STEP 9: Enable PAE + Long Mode
// ============================================================
// Set CR4.PAE (bit 5)
raw { 0x0F, 0x20, 0xE0 } // mov eax, cr4
raw { 0x66, 0x0D, 0x20, 0x00, 0x00, 0x00 } // or eax, 0x20
raw { 0x0F, 0x22, 0xE0 } // mov cr4, eax

// Load PML4 into CR3
raw { 0x66, 0xB8, 0x00, 0x00, 0x01, 0x00 } // mov eax, 0x10000
raw { 0x0F, 0x22, 0xD8 } // mov cr3, eax

// Enable Long Mode via MSR 0xC0000080 (EFER)
// Set bit 8 (LME = Long Mode Enable)
raw { 0x66, 0xB9, 0x80, 0x00, 0x00, 0xC0 } // mov ecx, 0xC0000080
raw { 0x0F, 0x32 }       // rdmsr
raw { 0x66, 0x0D, 0x00, 0x01, 0x00, 0x00 } // or eax, 0x100
raw { 0x0F, 0x30 }       // wrmsr

// ============================================================
// STEP 10: Enable paging + protected mode (CR0)
// ============================================================
// Set CR0.PG (bit 31) + CR0.PE (bit 0)
raw { 0x0F, 0x20, 0xC0 } // mov eax, cr0
raw { 0x66, 0x0D, 0x01, 0x00, 0x00, 0x80 } // or eax, 0x80000001
raw { 0x0F, 0x22, 0xC0 } // mov cr0, eax

// ============================================================
// STEP 11: Far jump to 64-bit code segment
// ============================================================
// Jump to code64 selector (0x18) at next instruction
// This activates long mode
// far jmp 0x18:pm64_entry
// The target address is the next instruction after this jump
// We're at ~0x8000 + offset. Use absolute address.
// jmp far 0x18:0x00008xxx — we'll use a relative approach

// First: copy kernel from bounce buffer (0x20000) to 0x100000
// We're now in 64-bit mode after the far jump, but let's do
// the copy in 32-bit protected mode first, then switch to 64-bit.

// Actually, after setting CR0.PG+PE with long mode enabled in EFER,
// we're in compatibility mode (32-bit sub-mode of long mode).
// We need a far jump to a 64-bit code segment to enter full 64-bit.

// For the far jump, encode: 0xEA [offset32] [selector16]
// But we need to know the exact address. Let's use a known address.
// We'll place the 64-bit entry at a fixed offset.

// Copy kernel in 32-bit compatibility mode first:
// Source: 0x20000, Dest: 0x100000, Size: 64KB (0x10000)
// Use 32-bit addressing (we have flat segments from GDT)

// Set data segments to 0x10 (data32)
raw { 0x66, 0xB8, 0x10, 0x00 } // mov ax, 0x10
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x8E, 0xD0 }       // mov ss, ax

// Copy 64KB from 0x20000 to 0x100000
// ESI = 0x20000, EDI = 0x100000, ECX = 0x4000 (16384 dwords = 64KB)
raw { 0x66, 0xBE, 0x00, 0x00, 0x02, 0x00 } // mov esi, 0x20000
raw { 0x66, 0xBF, 0x00, 0x00, 0x10, 0x00 } // mov edi, 0x100000
raw { 0x66, 0xB9, 0x00, 0x40, 0x00, 0x00 } // mov ecx, 0x4000
raw { 0xF3, 0x66, 0xA5 } // rep movsd

// Now far jump to 64-bit code
// jmp 0x18:0x00008FFF — but we need the exact address
// Use the encoding: EA [4-byte offset] [2-byte selector]
// The 64-bit entry point will be right after this jump instruction
// This jump is 7 bytes: EA xx xx xx xx 18 00
// So target = current_address + 7

// We'll use a fixed known address for the 64-bit entry
// Place it at 0x8F00 (well within our stage2 space)
// jmp far 0x18:0x00008F00
raw { 0xEA, 0x00, 0x8F, 0x00, 0x00, 0x18, 0x00 }

// ============================================================
// Padding to reach 0x8F00 (offset 0x0F00 from 0x8000)
// Fill with NOPs — the exact amount depends on code size above
// We'll use a generous NOP sled
// ============================================================
raw { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 }
raw { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 }
raw { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 }
raw { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 }
raw { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 }
raw { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 }
raw { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 }
raw { 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90 }

// ============================================================
// 64-BIT ENTRY POINT (at 0x8F00)
// ============================================================
// We are now in 64-bit long mode!
// Set up 64-bit data segments
// mov ax, 0x20 (data64 selector)
raw { 0x66, 0xB8, 0x20, 0x00 }
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x8E, 0xD0 }       // mov ss, ax
raw { 0x8E, 0xE0 }       // mov fs, ax
raw { 0x8E, 0xE8 }       // mov gs, ax

// Set up 64-bit stack at 0x90000
// mov rsp, 0x90000
raw { 0x48, 0xBC, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00 }

// ============================================================
// STEP 12: Jump to kernel at 0x100000
// ============================================================
// mov rax, 0x100000
raw { 0x48, 0xB8, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00 }
// jmp rax
raw { 0xFF, 0xE0 }

// ============================================================
// If kernel returns (should never happen), halt
// ============================================================
cli
hlt
raw { 0xEB, 0xFE }
