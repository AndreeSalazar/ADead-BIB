// ============================================================
// FastOS — Stage 2: Boot Mode Switch (ADead-BIB)
// ============================================================
// Loaded at 0x8000 by stage1. Runs in 16-bit real mode.
//
// Full boot sequence:
//   1. Enable A20 line (fast method + keyboard controller)
//   2. Get E820 memory map
//   3. Set VBE video mode (1024x768x32) via INT 10h
//   4. Load kernel binary from disk to 0x100000
//   5. Write BootInfo struct at 0x9000
//   6. Set up GDT (code32, data32, code64, data64)
//   7. Switch to Protected Mode (32-bit)
//   8. Set up identity-mapped page tables (PML4→PDPT→PD)
//   9. Enable PAE + Long Mode via MSR
//  10. Switch to Long Mode (64-bit)
//  11. Jump to kernel_main at 0x100000
//
// Memory map:
//   0x7C00       Stage1 (boot sector)
//   0x7E00       Boot drive number (saved by stage1)
//   0x8000       Stage2 (this file)
//   0x9000       BootInfo struct (64 bytes)
//   0x9100       E820 memory map entries
//   0x10000      Page tables (PML4, PDPT, PD) — 3 pages
//   0x70000      Temporary GDT
//   0x100000     Kernel binary (loaded from disk)
//
// ADead-BIB generates ALL bytes. Zero ASM.
// ============================================================

// ============================================================
// STEP 1: Enable A20 line
// ============================================================
// Fast A20 method: port 0x92
raw { 0xE4, 0x92 }       // in al, 0x92
raw { 0x0C, 0x02 }       // or al, 2
raw { 0x24, 0xFE }       // and al, 0xFE (don't reset)
raw { 0xE6, 0x92 }       // out 0x92, al

// Keyboard controller A20 fallback
raw { 0xE4, 0x64 }       // in al, 0x64
raw { 0xA8, 0x02 }       // test al, 2
raw { 0x75, 0xFB }       // jnz -5 (wait for input buffer empty)
raw { 0xB0, 0xD1 }       // mov al, 0xD1 (write output port)
raw { 0xE6, 0x64 }       // out 0x64, al
raw { 0xE4, 0x64 }       // in al, 0x64
raw { 0xA8, 0x02 }       // test al, 2
raw { 0x75, 0xFB }       // jnz -5
raw { 0xB0, 0xDF }       // mov al, 0xDF (A20 enable)
raw { 0xE6, 0x60 }       // out 0x60, al

// ============================================================
// STEP 2: Get E820 memory map → store at 0x9100
// ============================================================
// Set ES:DI = 0x0000:0x9100
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0xBF, 0x00, 0x91 } // mov di, 0x9100
raw { 0x31, 0xDB }       // xor ebx, ebx (continuation = 0)
raw { 0x31, 0xF6 }       // xor si, si (entry count)

// e820_loop:
raw { 0x66, 0xB8, 0x20, 0xE8, 0x00, 0x00 } // mov eax, 0x0000E820
// mov ecx, 24
raw { 0x66, 0xB9, 0x18, 0x00, 0x00, 0x00 } // mov ecx, 24
// mov edx, 0x534D4150 ('SMAP')
raw { 0x66, 0xBA, 0x50, 0x41, 0x4D, 0x53 } // mov edx, 0x534D4150
// int 0x15
int_call(0x15)

// jc e820_done (carry = error or end)
raw { 0x72, 0x19 }       // jc +25 (skip to e820_done)

// Increment count
raw { 0x46 }              // inc si

// Advance DI by 24 bytes
raw { 0x83, 0xC7, 0x18 } // add di, 24

// Check if ebx = 0 (last entry)
raw { 0x66, 0x09, 0xDB } // or ebx, ebx
raw { 0x74, 0x0E }       // jz e820_done (+14)

// Loop: mov eax, 0xE820; mov ecx, 24; mov edx, SMAP; int 15h
raw { 0x66, 0xB8, 0x20, 0xE8, 0x00, 0x00 }
raw { 0x66, 0xB9, 0x18, 0x00, 0x00, 0x00 }
raw { 0x66, 0xBA, 0x50, 0x41, 0x4D, 0x53 }
int_call(0x15)
raw { 0x73, 0xE5 }       // jnc back to inc si (-27)

// e820_done:
// Store entry count at 0x9000 + 36 (memory_map_count field)
// We'll write the full BootInfo later. Save SI for now.
raw { 0x89, 0x36, 0x50, 0x91 } // mov [0x9150], si (temp save count)

// ============================================================
// STEP 3: Set VBE video mode 1024x768x32
// ============================================================
// Try VBE mode 0x118 (1024x768x32)
// AX = 0x4F02 (set VBE mode)
// BX = 0x4118 (mode 0x118 + linear framebuffer bit 14)
raw { 0xB8, 0x02, 0x4F } // mov ax, 0x4F02
raw { 0xBB, 0x18, 0x41 } // mov bx, 0x4118
int_call(0x10)

// Check if VBE succeeded (AL = 0x4F)
raw { 0x3C, 0x4F }       // cmp al, 0x4F
raw { 0x74, 0x0E }       // je vbe_ok (+14)

// VBE failed — try mode 0x115 (800x600x32)
raw { 0xB8, 0x02, 0x4F } // mov ax, 0x4F02
raw { 0xBB, 0x15, 0x41 } // mov bx, 0x4115
int_call(0x10)
raw { 0x3C, 0x4F }       // cmp al, 0x4F
raw { 0x74, 0x02 }       // je vbe_ok (+2)

// Both failed — continue anyway (kernel will use VGA text fallback)
raw { 0xEB, 0x00 }       // jmp vbe_ok (nop jump, fall through)

// vbe_ok:
// Get VBE mode info to find framebuffer address
// AX = 0x4F01, CX = mode, ES:DI = buffer at 0x9200
raw { 0xBF, 0x00, 0x92 } // mov di, 0x9200
raw { 0xB8, 0x01, 0x4F } // mov ax, 0x4F01
raw { 0xB9, 0x18, 0x01 } // mov cx, 0x0118
int_call(0x10)

// Read framebuffer address from VBE mode info (offset 40 = 0x28)
// PhysBasePtr is at ES:DI+40 (dword)
// We'll read it later when writing BootInfo

// ============================================================
// STEP 4: Load kernel from disk to 0x100000
// ============================================================
// We can't load directly above 1MB in real mode (A20 is on but
// segments can only reach ~1MB). Use a bounce buffer at 0x20000
// and copy via unreal mode or load in chunks.
//
// Strategy: Load kernel sectors to 0x20000, then use
// protected mode copy to move to 0x100000.
//
// Load 128 sectors (64KB) from sector 18 (after stage1+stage2)
// to 0x2000:0x0000 = 0x20000

// Reset disk
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8A, 0x16, 0x00, 0x7E } // mov dl, [0x7E00] (boot drive)
int_call(0x13)

// Set ES = 0x2000 (target = 0x20000)
raw { 0xB8, 0x00, 0x20 } // mov ax, 0x2000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xDB }       // xor bx, bx (offset 0)

// Load kernel in 3 chunks of 127 sectors each (3 * 127 * 512 = 195KB)
// Chunk 1: LBA 17, 127 sectors → 0x2000:0x0000 (0x20000)
// Chunk 2: LBA 144, 127 sectors → 0x3000:0xFC00 (0x3FC00)
// Chunk 3: LBA 271, 127 sectors → 0x5000:0xF800 (0x5F800)
// Actually simpler: use segment:0 for each chunk
// Chunk 1: 127 sectors → seg 0x2000 (0x20000-0x2FE00)
// Chunk 2: 127 sectors → seg 0x4000 (0x40000-0x4FE00)
// Chunk 3: 127 sectors → seg 0x6000 (0x60000-0x6FE00)

raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax

// --- Chunk 1: 127 sectors from LBA 17 to 0x2000:0 ---
raw { 0xC6, 0x06, 0x10, 0x7E, 0x10 } // mov byte [0x7E10], 16
raw { 0xC6, 0x06, 0x11, 0x7E, 0x00 } // mov byte [0x7E11], 0
raw { 0xC7, 0x06, 0x12, 0x7E, 0x7F, 0x00 } // mov word [0x7E12], 127 (sectors)
raw { 0xC7, 0x06, 0x14, 0x7E, 0x00, 0x00 } // mov word [0x7E14], 0x0000
raw { 0xC7, 0x06, 0x16, 0x7E, 0x00, 0x20 } // mov word [0x7E16], 0x2000
raw { 0xC7, 0x06, 0x18, 0x7E, 0x03, 0x00 } // mov word [0x7E18], 3 (kernel starts at LBA 3)
raw { 0xC7, 0x06, 0x1A, 0x7E, 0x00, 0x00 } // mov word [0x7E1A], 0
raw { 0xC7, 0x06, 0x1C, 0x7E, 0x00, 0x00 } // mov word [0x7E1C], 0
raw { 0xC7, 0x06, 0x1E, 0x7E, 0x00, 0x00 } // mov word [0x7E1E], 0
raw { 0xB4, 0x42 }       // mov ah, 0x42
raw { 0x8A, 0x16, 0x00, 0x7E } // mov dl, [0x7E00]
raw { 0xBE, 0x10, 0x7E } // mov si, 0x7E10
int_call(0x13)
raw { 0x73, 0x02 }       // jnc chunk1_ok (+2)
raw { 0xEB, 0x00 }       // jmp (skip, continue anyway)
// chunk1_ok:

// --- Chunk 2: 127 sectors from LBA 144 to 0x4000:0 ---
raw { 0xC7, 0x06, 0x12, 0x7E, 0x7F, 0x00 } // sectors = 127
raw { 0xC7, 0x06, 0x16, 0x7E, 0x00, 0x40 } // segment = 0x4000
raw { 0xC7, 0x06, 0x18, 0x7E, 0x82, 0x00 } // LBA = 130 (3+127)
raw { 0xB4, 0x42 }       // mov ah, 0x42
raw { 0x8A, 0x16, 0x00, 0x7E } // mov dl, [0x7E00]
raw { 0xBE, 0x10, 0x7E } // mov si, 0x7E10
int_call(0x13)
raw { 0x73, 0x02 }       // jnc chunk2_ok
raw { 0xEB, 0x00 }       // jmp skip

// --- Chunk 3: 127 sectors from LBA 271 to 0x6000:0 ---
raw { 0xC7, 0x06, 0x12, 0x7E, 0x7F, 0x00 } // sectors = 127
raw { 0xC7, 0x06, 0x16, 0x7E, 0x00, 0x60 } // segment = 0x6000
raw { 0xC7, 0x06, 0x18, 0x7E, 0x01, 0x01 } // LBA = 257 (130+127)
raw { 0xB4, 0x42 }       // mov ah, 0x42
raw { 0x8A, 0x16, 0x00, 0x7E } // mov dl, [0x7E00]
raw { 0xBE, 0x10, 0x7E } // mov si, 0x7E10
int_call(0x13)

// load_ok:

// ============================================================
// STEP 5: Write BootInfo at 0x9000
// ============================================================
// BootInfo struct (64 bytes):
//   u32 magic          = 0x464F5321 ("FOS!")
//   u64 fb_addr        = from VBE mode info
//   u32 fb_width       = 1024
//   u32 fb_height      = 768
//   u32 fb_bpp         = 32
//   u32 fb_pitch       = from VBE mode info
//   u64 mmap_addr      = 0x9100
//   u32 mmap_count     = from E820
//   u8[20] reserved    = 0

// Zero out BootInfo area
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0xBF, 0x00, 0x90 } // mov di, 0x9000
raw { 0xB9, 0x20, 0x00 } // mov cx, 32 (32 words = 64 bytes)
raw { 0xF3, 0xAB }       // rep stosw

// Magic: 0x464F5321 at [0x9000] (offset 0)
raw { 0xC7, 0x06, 0x00, 0x90, 0x21, 0x53 } // mov word [0x9000], 0x5321
raw { 0xC7, 0x06, 0x02, 0x90, 0x4F, 0x46 } // mov word [0x9002], 0x464F

// _pad0: zero at offset 4
raw { 0xC7, 0x06, 0x04, 0x90, 0x00, 0x00 } // mov word [0x9004], 0
raw { 0xC7, 0x06, 0x06, 0x90, 0x00, 0x00 } // mov word [0x9006], 0

// Framebuffer address at offset 8 (u64): read from VBE mode info PhysBasePtr at 0x9228
raw { 0xA1, 0x28, 0x92 } // mov ax, [0x9228]
raw { 0xA3, 0x08, 0x90 } // mov [0x9008], ax
raw { 0x8B, 0x06, 0x2A, 0x92 } // mov ax, [0x922A]
raw { 0xA3, 0x0A, 0x90 } // mov [0x900A], ax
// High dword of fb_addr = 0
raw { 0xC7, 0x06, 0x0C, 0x90, 0x00, 0x00 } // mov word [0x900C], 0
raw { 0xC7, 0x06, 0x0E, 0x90, 0x00, 0x00 } // mov word [0x900E], 0

// Width at offset 16 (u32): read from VBE mode info offset 18 (0x12) = XResolution
raw { 0x8B, 0x06, 0x12, 0x92 } // mov ax, [0x9212]
raw { 0xA3, 0x10, 0x90 } // mov [0x9010], ax
raw { 0xC7, 0x06, 0x12, 0x90, 0x00, 0x00 } // high word = 0

// Height at offset 20 (u32): read from VBE mode info offset 20 (0x14) = YResolution
raw { 0x8B, 0x06, 0x14, 0x92 } // mov ax, [0x9214]
raw { 0xA3, 0x14, 0x90 } // mov [0x9014], ax
raw { 0xC7, 0x06, 0x16, 0x90, 0x00, 0x00 } // high word = 0

// BPP at offset 24 (u32): read from VBE mode info offset 25 (0x19) = BitsPerPixel (byte)
raw { 0x31, 0xC0 }                         // xor ax, ax
raw { 0xA0, 0x19, 0x92 }                   // mov al, [0x9219]
raw { 0xA3, 0x18, 0x90 }                   // mov [0x9018], ax
raw { 0xC7, 0x06, 0x1A, 0x90, 0x00, 0x00 } // high word = 0

// Pitch at offset 28 (u32): read from VBE mode info offset 16 (0x10) = BytesPerScanLine
raw { 0x8B, 0x06, 0x10, 0x92 } // mov ax, [0x9210]
raw { 0xA3, 0x1C, 0x90 } // mov [0x901C], ax
raw { 0xC7, 0x06, 0x1E, 0x90, 0x00, 0x00 }

// Memory map address at offset 32 (u64): 0x9100
raw { 0xC7, 0x06, 0x20, 0x90, 0x00, 0x91 } // mov word [0x9020], 0x9100
raw { 0xC7, 0x06, 0x22, 0x90, 0x00, 0x00 }
raw { 0xC7, 0x06, 0x24, 0x90, 0x00, 0x00 }
raw { 0xC7, 0x06, 0x26, 0x90, 0x00, 0x00 }

// Memory map count at offset 40 (u32): from saved value at 0x9150
raw { 0x8B, 0x06, 0x50, 0x91 } // mov ax, [0x9150]
raw { 0xA3, 0x28, 0x90 } // mov [0x9028], ax
raw { 0xC7, 0x06, 0x2A, 0x90, 0x00, 0x00 }

// ============================================================
// STEP 6: Set up GDT at 0x70000
// ============================================================
// GDT entries (8 bytes each):
//   0x00: Null descriptor
//   0x08: Code32 (32-bit code, base=0, limit=4GB, ring 0)
//   0x10: Data32 (32-bit data, base=0, limit=4GB, ring 0)
//   0x18: Code64 (64-bit code, base=0, limit=0, ring 0)
//   0x20: Data64 (64-bit data, base=0, limit=0, ring 0)

// Null descriptor at 0x70000
// Set ES = 0x7000
raw { 0xB8, 0x00, 0x70 } // mov ax, 0x7000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xFF }       // xor di, di

// Null descriptor (8 bytes of 0)
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 } // mov word es:[di], 0
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }

// Code32 descriptor at offset 0x08: base=0, limit=0xFFFFF, 32-bit code
// Bytes: FF FF 00 00 00 9A CF 00
raw { 0x26, 0xC7, 0x05, 0xFF, 0xFF } // limit low
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 } // base low
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x9A } // base mid + access (code, readable, ring 0)
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0xCF, 0x00 } // flags (4KB gran, 32-bit) + limit high + base high
raw { 0x83, 0xC7, 0x02 }

// Data32 descriptor at offset 0x10: base=0, limit=0xFFFFF, 32-bit data
// Bytes: FF FF 00 00 00 92 CF 00
raw { 0x26, 0xC7, 0x05, 0xFF, 0xFF }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x92 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0xCF, 0x00 }
raw { 0x83, 0xC7, 0x02 }

// Code64 descriptor at offset 0x18: 64-bit code segment
// Bytes: 00 00 00 00 00 9A 20 00
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x9A } // access: code, readable, ring 0
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x20, 0x00 } // flags: L=1 (long mode), D=0
raw { 0x83, 0xC7, 0x02 }

// Data64 descriptor at offset 0x20: 64-bit data segment
// Bytes: 00 00 00 00 00 92 00 00
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x92 }
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 }
raw { 0x83, 0xC7, 0x02 }

// GDT pointer at 0x70028 (after GDT entries)
// limit = 5*8 - 1 = 39 = 0x27
// base = 0x00070000
raw { 0x26, 0xC7, 0x05, 0x27, 0x00 } // limit
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x00, 0x00 } // base low (0x0000)
raw { 0x83, 0xC7, 0x02 }
raw { 0x26, 0xC7, 0x05, 0x07, 0x00 } // base high (0x0007)
raw { 0x83, 0xC7, 0x02 }

// Restore DS = 0
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax

// ============================================================
// STEP 7: Disable interrupts and load GDT
// ============================================================
cli

// lgdt [0x70028] — GDT pointer is at 0x7000:0x0028
// In real mode with DS=0, we need to address 0x70028
// Use: lgdt [ds:addr] but addr must be < 64KB
// Solution: set DS = 0x7000 temporarily
raw { 0xB8, 0x00, 0x70 } // mov ax, 0x7000
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0x0F, 0x01, 0x16, 0x28, 0x00 } // lgdt [0x0028]

// Restore DS = 0
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax

// ============================================================
// STEP 8: Set up page tables at 0x10000
// ============================================================
// PML4 at 0x10000, PDPT at 0x11000, PD0-PD3 at 0x12000-0x15000
// Identity map first 4GB using 2MB pages (needed for VBE LFB at ~0xE0000000)

// Clear page table area (6 pages = 24KB = 12288 words)
raw { 0xB8, 0x00, 0x10 } // mov ax, 0x1000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xFF }       // xor di, di
raw { 0xB9, 0x00, 0x30 } // mov cx, 0x3000 (12288 words = 6 pages)
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0xF3, 0xAB }       // rep stosw

// PML4[0] → PDPT at 0x11000 (present + writable)
raw { 0xB8, 0x00, 0x10 } // mov ax, 0x1000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xFF }       // xor di, di
raw { 0x26, 0x66, 0xC7, 0x05, 0x03, 0x10, 0x01, 0x00 } // mov dword es:[di], 0x00011003

// PDPT[0] → PD0 at 0x12000 (0x00000000-0x3FFFFFFF)
raw { 0xBF, 0x00, 0x10 } // mov di, 0x1000
raw { 0x26, 0x66, 0xC7, 0x05, 0x03, 0x20, 0x01, 0x00 } // mov dword es:[di], 0x00012003

// PDPT[1] → PD1 at 0x13000 (0x40000000-0x7FFFFFFF)
raw { 0xBF, 0x08, 0x10 } // mov di, 0x1008
raw { 0x26, 0x66, 0xC7, 0x05, 0x03, 0x30, 0x01, 0x00 } // mov dword es:[di], 0x00013003

// PDPT[2] → PD2 at 0x14000 (0x80000000-0xBFFFFFFF)
raw { 0xBF, 0x10, 0x10 } // mov di, 0x1010
raw { 0x26, 0x66, 0xC7, 0x05, 0x03, 0x40, 0x01, 0x00 } // mov dword es:[di], 0x00014003

// PDPT[3] → PD3 at 0x15000 (0xC0000000-0xFFFFFFFF)
raw { 0xBF, 0x18, 0x10 } // mov di, 0x1018
raw { 0x26, 0x66, 0xC7, 0x05, 0x03, 0x50, 0x01, 0x00 } // mov dword es:[di], 0x00015003

// PD entries: 4 × 512 = 2048 entries × 2MB = 4GB identity mapped
// Each entry: addr | 0x83 (present + writable + page size = 2MB)
// PD0 starts at 0x12000 (ES:0x2000), runs through PD3 at 0x15000
raw { 0xBF, 0x00, 0x20 } // mov di, 0x2000
raw { 0x66, 0x31, 0xC0 } // xor eax, eax (start address = 0)
raw { 0x66, 0x0D, 0x83, 0x00, 0x00, 0x00 } // or eax, 0x83 (present+write+PS)
raw { 0xB9, 0x00, 0x08 } // mov cx, 2048 (4 × 512)

// pd_loop:
raw { 0x26, 0x66, 0x89, 0x05 } // mov dword es:[di], eax
raw { 0x83, 0xC7, 0x04 }       // add di, 4
raw { 0x26, 0x66, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x00 } // mov dword es:[di], 0 (high)
raw { 0x83, 0xC7, 0x04 }       // add di, 4
raw { 0x66, 0x05, 0x00, 0x00, 0x20, 0x00 } // add eax, 0x200000 (2MB)
raw { 0x49 }                     // dec cx
raw { 0x75, 0xE6 }               // jnz pd_loop (-26)

// ============================================================
// STEP 9: Enable PAE + Long Mode
// ============================================================
// Set CR4.PAE (bit 5)
raw { 0x0F, 0x20, 0xE0 } // mov eax, cr4
raw { 0x66, 0x0D, 0x20, 0x00, 0x00, 0x00 } // or eax, 0x20
raw { 0x0F, 0x22, 0xE0 } // mov cr4, eax

// Load PML4 into CR3
raw { 0x66, 0xB8, 0x00, 0x00, 0x01, 0x00 } // mov eax, 0x10000
raw { 0x0F, 0x22, 0xD8 } // mov cr3, eax

// Enable Long Mode via MSR 0xC0000080 (EFER)
// Set bit 8 (LME = Long Mode Enable)
raw { 0x66, 0xB9, 0x80, 0x00, 0x00, 0xC0 } // mov ecx, 0xC0000080
raw { 0x0F, 0x32 }       // rdmsr
raw { 0x66, 0x0D, 0x00, 0x01, 0x00, 0x00 } // or eax, 0x100
raw { 0x0F, 0x30 }       // wrmsr

// ============================================================
// STEP 10: Prepare far jump pointers (while still in real mode)
// ============================================================
// Store two far pointers at known addresses before enabling paging:
//   0x7E20: far ptr for 32-bit entry (offset32 + selector16)
//   0x7E28: far ptr for 64-bit entry (offset32 + selector16)
// The 32-bit entry is at 0x834F, the 64-bit entry at 0x8393.
// stage2 = 968 bytes. 32-bit entry at offset 847, 64-bit at offset 915.

// Write 32-bit far pointer at 0x7E20: offset=0x0000834F, sel=0x0008
raw { 0xC7, 0x06, 0x20, 0x7E, 0x4F, 0x83 } // mov word [0x7E20], 0x834F
raw { 0xC7, 0x06, 0x22, 0x7E, 0x00, 0x00 } // mov word [0x7E22], 0x0000
raw { 0xC7, 0x06, 0x24, 0x7E, 0x08, 0x00 } // mov word [0x7E24], 0x0008

// Write 64-bit far pointer at 0x7E28: offset=0x00008393, sel=0x0018
raw { 0xC7, 0x06, 0x28, 0x7E, 0x93, 0x83 } // mov word [0x7E28], 0x8393
raw { 0xC7, 0x06, 0x2A, 0x7E, 0x00, 0x00 } // mov word [0x7E2A], 0x0000
raw { 0xC7, 0x06, 0x2C, 0x7E, 0x18, 0x00 } // mov word [0x7E2C], 0x0018

// ============================================================
// STEP 11: Enable paging + protected mode (CR0)
// ============================================================
// Set CR0.PG (bit 31) + CR0.PE (bit 0)
raw { 0x0F, 0x20, 0xC0 } // mov eax, cr0
raw { 0x66, 0x0D, 0x01, 0x00, 0x00, 0x80 } // or eax, 0x80000001
raw { 0x0F, 0x22, 0xC0 } // mov cr0, eax

// ============================================================
// STEP 12: Far jump to 32-bit code via memory pointer
// ============================================================
// jmp far [0x7E20] — loads CS:EIP from memory
// Encoding: 66 FF 2E 20 7E (with operand size override for 32-bit offset)
raw { 0x66, 0xFF, 0x2E, 0x20, 0x7E } // jmp far dword [0x7E20]

// ============================================================
// 32-BIT COMPATIBILITY MODE ENTRY
// ============================================================
// CS=0x08 (32-bit code). Set data segments and copy kernel.

// Set data segments to 0x10 (data32)
raw { 0xB8, 0x10, 0x00, 0x00, 0x00 } // mov eax, 0x10
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x8E, 0xD0 }       // mov ss, ax

// Copy kernel: 3 chunks from bounce buffers to 0x100000
// Chunk 1: 0x20000 → 0x100000 (127*512 = 65024 bytes = 0xFE00)
raw { 0xBE, 0x00, 0x00, 0x02, 0x00 } // mov esi, 0x20000
raw { 0xBF, 0x00, 0x00, 0x10, 0x00 } // mov edi, 0x100000
raw { 0xB9, 0x80, 0x3F, 0x00, 0x00 } // mov ecx, 0x3F80 (65024/4)
raw { 0xF3, 0xA5 }       // rep movsd
// Chunk 2: 0x40000 → 0x10FE00 (127*512 bytes)
raw { 0xBE, 0x00, 0x00, 0x04, 0x00 } // mov esi, 0x40000
raw { 0xBF, 0x00, 0xFE, 0x10, 0x00 } // mov edi, 0x10FE00
raw { 0xB9, 0x80, 0x3F, 0x00, 0x00 } // mov ecx, 0x3F80
raw { 0xF3, 0xA5 }       // rep movsd
// Chunk 3: 0x60000 → 0x11FC00 (127*512 bytes)
raw { 0xBE, 0x00, 0x00, 0x06, 0x00 } // mov esi, 0x60000
raw { 0xBF, 0x00, 0xFC, 0x11, 0x00 } // mov edi, 0x11FC00
raw { 0xB9, 0x80, 0x3F, 0x00, 0x00 } // mov ecx, 0x3F80
raw { 0xF3, 0xA5 }       // rep movsd

// Far jump to 64-bit code via memory pointer at 0x7E28
raw { 0xFF, 0x2D, 0x28, 0x7E, 0x00, 0x00 } // jmp far [0x7E28]

// ============================================================
// 64-BIT LONG MODE ENTRY
// ============================================================
// CS=0x18 (64-bit code). Full 64-bit long mode active.

// Set up 64-bit data segments (selector 0x20)
raw { 0x66, 0xB8, 0x20, 0x00 } // mov ax, 0x20
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x8E, 0xD0 }       // mov ss, ax
raw { 0x8E, 0xE0 }       // mov fs, ax
raw { 0x8E, 0xE8 }       // mov gs, ax

// Set up 64-bit stack at 0x200000 (2MB, above kernel)
raw { 0x48, 0xBC, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00 } // mov rsp, 0x200000

// Jump to kernel at 0x100000
raw { 0x48, 0xB8, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00 } // mov rax, 0x100000
raw { 0xFF, 0xE0 } // jmp rax

// Halt if kernel returns
cli
hlt
raw { 0xEB, 0xFE }
