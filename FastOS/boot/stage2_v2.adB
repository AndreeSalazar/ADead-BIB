// ============================================================
// FastOS — Stage 2: Boot Mode Switch (ADead-BIB v3.3)
// ============================================================
// Loaded at 0x8000 by stage1. Runs in 16-bit real mode.
// 
// REWRITTEN with named labels — NO hardcoded offsets!
// Uses ADead-BIB v3.3 label system for automatic resolution.
//
// Full boot sequence:
//   1. Enable A20 line (fast method + keyboard controller)
//   2. Get E820 memory map
//   3. Set VBE video mode (1024x768x32) via INT 10h
//   4. Load kernel binary from disk to 0x100000
//   5. Write BootInfo struct at 0x9000
//   6. Set up GDT (code32, data32, code64, data64)
//   7. Switch to Protected Mode (32-bit)
//   8. Set up identity-mapped page tables (PML4→PDPT→PD)
//   9. Enable PAE + Long Mode via MSR
//  10. Switch to Long Mode (64-bit)
//  11. Jump to kernel_main at 0x100000
//
// Memory map:
//   0x7C00       Stage1 (boot sector)
//   0x7E00       Boot drive number (saved by stage1)
//   0x8000       Stage2 (this file)
//   0x9000       BootInfo struct (64 bytes)
//   0x9100       E820 memory map entries
//   0x10000      Page tables (PML4, PDPT, PD) — 3 pages
//   0x70000      Temporary GDT
//   0x100000     Kernel binary (loaded from disk)
// ============================================================

// ============================================================
// STEP 1: Enable A20 line
// ============================================================
// Fast A20 method: port 0x92
raw { 0xE4, 0x92 }       // in al, 0x92
raw { 0x0C, 0x02 }       // or al, 2
raw { 0x24, 0xFE }       // and al, 0xFE (don't reset)
raw { 0xE6, 0x92 }       // out 0x92, al

// Keyboard controller A20 fallback
label a20_wait1:
raw { 0xE4, 0x64 }       // in al, 0x64
raw { 0xA8, 0x02 }       // test al, 2
jnz a20_wait1            // wait for input buffer empty

raw { 0xB0, 0xD1 }       // mov al, 0xD1 (write output port)
raw { 0xE6, 0x64 }       // out 0x64, al

label a20_wait2:
raw { 0xE4, 0x64 }       // in al, 0x64
raw { 0xA8, 0x02 }       // test al, 2
jnz a20_wait2            // wait for input buffer empty

raw { 0xB0, 0xDF }       // mov al, 0xDF (A20 enable)
raw { 0xE6, 0x60 }       // out 0x60, al

// ============================================================
// STEP 2: Get E820 memory map → store at 0x9100
// ============================================================
// Set ES:DI = 0x0000:0x9100
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0xBF, 0x00, 0x91 } // mov di, 0x9100
raw { 0x31, 0xDB }       // xor ebx, ebx (continuation = 0)
raw { 0x31, 0xF6 }       // xor si, si (entry count)

label e820_loop:
raw { 0x66, 0xB8, 0x20, 0xE8, 0x00, 0x00 } // mov eax, 0x0000E820
raw { 0x66, 0xB9, 0x18, 0x00, 0x00, 0x00 } // mov ecx, 24
raw { 0x66, 0xBA, 0x50, 0x41, 0x4D, 0x53 } // mov edx, 0x534D4150 ('SMAP')
int_call(0x15)

jc e820_done             // carry = error or end

// Increment count
raw { 0x46 }             // inc si

// Advance DI by 24 bytes
raw { 0x83, 0xC7, 0x18 } // add di, 24

// Check if ebx = 0 (last entry)
raw { 0x66, 0x09, 0xDB } // or ebx, ebx
jz e820_done             // if ebx=0, done

// Continue loop
jmp e820_loop

label e820_done:
// Store entry count at 0x9150 (temp save)
raw { 0x89, 0x36, 0x50, 0x91 } // mov [0x9150], si

// ============================================================
// STEP 3: Set VBE video mode 1024x768x32
// ============================================================
// Try VBE mode 0x118 (1024x768x32)
raw { 0xB8, 0x02, 0x4F } // mov ax, 0x4F02
raw { 0xBB, 0x18, 0x41 } // mov bx, 0x4118
int_call(0x10)

// Check if VBE succeeded (AL = 0x4F)
raw { 0x3C, 0x4F }       // cmp al, 0x4F
jz vbe_ok

// VBE failed — try mode 0x115 (800x600x32)
raw { 0xB8, 0x02, 0x4F } // mov ax, 0x4F02
raw { 0xBB, 0x15, 0x41 } // mov bx, 0x4115
int_call(0x10)

// Continue anyway (kernel will use VGA text fallback if needed)

label vbe_ok:
// Get VBE mode info to find framebuffer address
raw { 0xBF, 0x00, 0x92 } // mov di, 0x9200
raw { 0xB8, 0x01, 0x4F } // mov ax, 0x4F01
raw { 0xB9, 0x18, 0x01 } // mov cx, 0x0118
int_call(0x10)

// ============================================================
// STEP 4: Load kernel from disk to bounce buffers
// ============================================================
// Reset disk
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8A, 0x16, 0x00, 0x7E } // mov dl, [0x7E00] (boot drive)
int_call(0x13)

// Set up DAP at 0x7E10
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax

// --- Chunk 1: 127 sectors from LBA 3 to 0x2000:0 ---
raw { 0xC6, 0x06, 0x10, 0x7E, 0x10 } // mov byte [0x7E10], 16 (DAP size)
raw { 0xC6, 0x06, 0x11, 0x7E, 0x00 } // mov byte [0x7E11], 0
raw { 0xC7, 0x06, 0x12, 0x7E, 0x7F, 0x00 } // mov word [0x7E12], 127 (sectors)
raw { 0xC7, 0x06, 0x14, 0x7E, 0x00, 0x00 } // mov word [0x7E14], 0x0000
raw { 0xC7, 0x06, 0x16, 0x7E, 0x00, 0x20 } // mov word [0x7E16], 0x2000
raw { 0xC7, 0x06, 0x18, 0x7E, 0x03, 0x00 } // mov word [0x7E18], 3 (LBA low)
raw { 0xC7, 0x06, 0x1A, 0x7E, 0x00, 0x00 } // mov word [0x7E1A], 0
raw { 0xC7, 0x06, 0x1C, 0x7E, 0x00, 0x00 } // mov word [0x7E1C], 0
raw { 0xC7, 0x06, 0x1E, 0x7E, 0x00, 0x00 } // mov word [0x7E1E], 0
raw { 0xB4, 0x42 }       // mov ah, 0x42
raw { 0x8A, 0x16, 0x00, 0x7E } // mov dl, [0x7E00]
raw { 0xBE, 0x10, 0x7E } // mov si, 0x7E10
int_call(0x13)
jnc chunk1_ok
jmp chunk1_ok            // continue anyway
label chunk1_ok:

// --- Chunk 2: 127 sectors from LBA 130 to 0x4000:0 ---
raw { 0xC7, 0x06, 0x12, 0x7E, 0x7F, 0x00 } // sectors = 127
raw { 0xC7, 0x06, 0x16, 0x7E, 0x00, 0x40 } // segment = 0x4000
raw { 0xC7, 0x06, 0x18, 0x7E, 0x82, 0x00 } // LBA = 130 (3+127)
raw { 0xB4, 0x42 }       // mov ah, 0x42
raw { 0x8A, 0x16, 0x00, 0x7E } // mov dl, [0x7E00]
raw { 0xBE, 0x10, 0x7E } // mov si, 0x7E10
int_call(0x13)
jnc chunk2_ok
jmp chunk2_ok
label chunk2_ok:

// --- Chunk 3: 127 sectors from LBA 257 to 0x6000:0 ---
raw { 0xC7, 0x06, 0x12, 0x7E, 0x7F, 0x00 } // sectors = 127
raw { 0xC7, 0x06, 0x16, 0x7E, 0x00, 0x60 } // segment = 0x6000
raw { 0xC7, 0x06, 0x18, 0x7E, 0x01, 0x01 } // LBA = 257 (130+127)
raw { 0xB4, 0x42 }       // mov ah, 0x42
raw { 0x8A, 0x16, 0x00, 0x7E } // mov dl, [0x7E00]
raw { 0xBE, 0x10, 0x7E } // mov si, 0x7E10
int_call(0x13)

label load_ok:

// ============================================================
// STEP 5: Write BootInfo at 0x9000
// ============================================================
// Zero out BootInfo area
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0xBF, 0x00, 0x90 } // mov di, 0x9000
raw { 0xB9, 0x20, 0x00 } // mov cx, 32 (32 words = 64 bytes)
raw { 0xF3, 0xAB }       // rep stosw

// Magic: 0x464F5321 at [0x9000]
raw { 0xC7, 0x06, 0x00, 0x90, 0x21, 0x53 } // mov word [0x9000], 0x5321
raw { 0xC7, 0x06, 0x02, 0x90, 0x4F, 0x46 } // mov word [0x9002], 0x464F

// _pad0: zero at offset 4
raw { 0xC7, 0x06, 0x04, 0x90, 0x00, 0x00 }
raw { 0xC7, 0x06, 0x06, 0x90, 0x00, 0x00 }

// Framebuffer address at offset 8: read from VBE mode info
raw { 0xA1, 0x28, 0x92 } // mov ax, [0x9228]
raw { 0xA3, 0x08, 0x90 } // mov [0x9008], ax
raw { 0x8B, 0x06, 0x2A, 0x92 } // mov ax, [0x922A]
raw { 0xA3, 0x0A, 0x90 } // mov [0x900A], ax
raw { 0xC7, 0x06, 0x0C, 0x90, 0x00, 0x00 }
raw { 0xC7, 0x06, 0x0E, 0x90, 0x00, 0x00 }

// Width at offset 16
raw { 0x8B, 0x06, 0x12, 0x92 } // mov ax, [0x9212]
raw { 0xA3, 0x10, 0x90 } // mov [0x9010], ax
raw { 0xC7, 0x06, 0x12, 0x90, 0x00, 0x00 }

// Height at offset 20
raw { 0x8B, 0x06, 0x14, 0x92 } // mov ax, [0x9214]
raw { 0xA3, 0x14, 0x90 } // mov [0x9014], ax
raw { 0xC7, 0x06, 0x16, 0x90, 0x00, 0x00 }

// BPP at offset 24
raw { 0x8A, 0x06, 0x19, 0x92 } // mov al, [0x9219]
raw { 0xA2, 0x18, 0x90 } // mov [0x9018], al
raw { 0xC6, 0x06, 0x19, 0x90, 0x00 }
raw { 0xC7, 0x06, 0x1A, 0x90, 0x00, 0x00 }

// Pitch at offset 28
raw { 0x8B, 0x06, 0x10, 0x92 } // mov ax, [0x9210]
raw { 0xA3, 0x1C, 0x90 } // mov [0x901C], ax
raw { 0xC7, 0x06, 0x1E, 0x90, 0x00, 0x00 }

// Memory map address at offset 32
raw { 0xC7, 0x06, 0x20, 0x90, 0x00, 0x91 }
raw { 0xC7, 0x06, 0x22, 0x90, 0x00, 0x00 }
raw { 0xC7, 0x06, 0x24, 0x90, 0x00, 0x00 }
raw { 0xC7, 0x06, 0x26, 0x90, 0x00, 0x00 }

// Memory map count at offset 40
raw { 0x8B, 0x06, 0x50, 0x91 } // mov ax, [0x9150]
raw { 0xA3, 0x28, 0x90 } // mov [0x9028], ax
raw { 0xC7, 0x06, 0x2A, 0x90, 0x00, 0x00 }

// ============================================================
// STEP 6: Set up GDT at 0x70000
// ============================================================
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax

// Null descriptor (8 bytes)
raw { 0xC7, 0x06, 0x00, 0x00, 0x00, 0x00 } // [0x70000] = 0
raw { 0x26, 0xC7, 0x06, 0x00, 0x00, 0x00, 0x00 } // es:[0x0000] = 0 (need segment override)

// Actually, let's use a simpler approach - write GDT bytes directly
// GDT at 0x70000:
//   0x00: Null (8 bytes of 0)
//   0x08: Code32 (32-bit code segment)
//   0x10: Data32 (32-bit data segment)
//   0x18: Code64 (64-bit code segment)
//   0x20: Data64 (64-bit data segment)

// Set ES = 0x7000
raw { 0xB8, 0x00, 0x70 } // mov ax, 0x7000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xFF }       // xor di, di

// Null descriptor (8 bytes)
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0xAB }             // stosw
raw { 0xAB }             // stosw
raw { 0xAB }             // stosw
raw { 0xAB }             // stosw

// Code32 descriptor: base=0, limit=0xFFFFF, 32-bit code, ring 0
// Bytes: FF FF 00 00 00 9A CF 00
raw { 0xB8, 0xFF, 0xFF } // mov ax, 0xFFFF
raw { 0xAB }             // stosw (limit low)
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0xAB }             // stosw (base low)
raw { 0xB8, 0x9A, 0x00 } // mov ax, 0x009A (access: present, ring0, code, readable)
raw { 0xAB }             // stosw
raw { 0xB8, 0xCF, 0x00 } // mov ax, 0x00CF (flags: 4KB granularity, 32-bit)
raw { 0xAB }             // stosw

// Data32 descriptor: base=0, limit=0xFFFFF, 32-bit data, ring 0
raw { 0xB8, 0xFF, 0xFF } // mov ax, 0xFFFF
raw { 0xAB }             // stosw
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0xAB }             // stosw
raw { 0xB8, 0x92, 0x00 } // mov ax, 0x0092 (access: present, ring0, data, writable)
raw { 0xAB }             // stosw
raw { 0xB8, 0xCF, 0x00 } // mov ax, 0x00CF
raw { 0xAB }             // stosw

// Code64 descriptor: 64-bit code segment
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0xAB }             // stosw
raw { 0xAB }             // stosw
raw { 0xB8, 0x9A, 0x00 } // mov ax, 0x009A
raw { 0xAB }             // stosw
raw { 0xB8, 0xAF, 0x00 } // mov ax, 0x00AF (flags: 64-bit code)
raw { 0xAB }             // stosw

// Data64 descriptor: 64-bit data segment
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0xAB }             // stosw
raw { 0xAB }             // stosw
raw { 0xB8, 0x92, 0x00 } // mov ax, 0x0092
raw { 0xAB }             // stosw
raw { 0xB8, 0x00, 0x00 } // mov ax, 0x0000
raw { 0xAB }             // stosw

// Set up GDTR at 0x7E30
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0xC7, 0x06, 0x30, 0x7E, 0x27, 0x00 } // limit = 39 (5 descriptors * 8 - 1)
raw { 0xC7, 0x06, 0x32, 0x7E, 0x00, 0x00 } // base low = 0x0000
raw { 0xC7, 0x06, 0x34, 0x7E, 0x07, 0x00 } // base high = 0x0007 (0x70000)

// Load GDT
raw { 0x0F, 0x01, 0x16, 0x30, 0x7E } // lgdt [0x7E30]

// ============================================================
// STEP 7-8: Set up page tables at 0x10000
// ============================================================
// Zero out 3 pages (PML4, PDPT, PD)
raw { 0xB8, 0x00, 0x10 } // mov ax, 0x1000
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x31, 0xFF }       // xor di, di
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0xB9, 0x00, 0x18 } // mov cx, 0x1800 (3 pages * 0x800 words)
raw { 0xF3, 0xAB }       // rep stosw

// PML4[0] = 0x11003 (points to PDPT at 0x11000, present+writable)
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0xC7, 0x06, 0x00, 0x00, 0x03, 0x10 } // [0x10000] = 0x1003 (wrong, need 0x11003)
// Actually need to write dword. Let's use 16-bit writes:
raw { 0xC7, 0x06, 0x00, 0x00, 0x03, 0x10 } // low word at 0x10000 = 0x1003
// Wait, segment is wrong. Let me fix this.

// Set DS = 0x1000 to access 0x10000 as DS:0
raw { 0xB8, 0x00, 0x10 } // mov ax, 0x1000
raw { 0x8E, 0xD8 }       // mov ds, ax

// PML4[0] = 0x11003
raw { 0xC7, 0x06, 0x00, 0x00, 0x03, 0x10 } // [DS:0x0000] = 0x1003 (low word)
raw { 0xC7, 0x06, 0x02, 0x00, 0x01, 0x00 } // [DS:0x0002] = 0x0001 (high word) → 0x00011003

// PDPT[0] = 0x12003 (points to PD at 0x12000)
raw { 0xC7, 0x06, 0x00, 0x10, 0x03, 0x20 } // [DS:0x1000] = 0x2003
raw { 0xC7, 0x06, 0x02, 0x10, 0x01, 0x00 } // [DS:0x1002] = 0x0001 → 0x00012003

// PD: Identity map first 2MB using 2MB pages
// PD[0] = 0x000083 (2MB page, present+writable+huge)
raw { 0xC7, 0x06, 0x00, 0x20, 0x83, 0x00 } // [DS:0x2000] = 0x0083
raw { 0xC7, 0x06, 0x02, 0x20, 0x00, 0x00 } // [DS:0x2002] = 0x0000

// Reset DS
raw { 0x31, 0xC0 }       // xor ax, ax
raw { 0x8E, 0xD8 }       // mov ds, ax

// ============================================================
// STEP 9: Enable PAE in CR4
// ============================================================
raw { 0x0F, 0x20, 0xE0 } // mov eax, cr4
raw { 0x66, 0x0D, 0x20, 0x00, 0x00, 0x00 } // or eax, 0x20 (PAE bit)
raw { 0x0F, 0x22, 0xE0 } // mov cr4, eax

// Load PML4 into CR3
raw { 0x66, 0xB8, 0x00, 0x00, 0x01, 0x00 } // mov eax, 0x10000
raw { 0x0F, 0x22, 0xD8 } // mov cr3, eax

// Enable Long Mode via MSR 0xC0000080 (EFER)
raw { 0x66, 0xB9, 0x80, 0x00, 0x00, 0xC0 } // mov ecx, 0xC0000080
raw { 0x0F, 0x32 }       // rdmsr
raw { 0x66, 0x0D, 0x00, 0x01, 0x00, 0x00 } // or eax, 0x100 (LME bit)
raw { 0x0F, 0x30 }       // wrmsr

// ============================================================
// STEP 10: Enable paging + protected mode (CR0)
// ============================================================
raw { 0x0F, 0x20, 0xC0 } // mov eax, cr0
raw { 0x66, 0x0D, 0x01, 0x00, 0x00, 0x80 } // or eax, 0x80000001 (PG + PE)
raw { 0x0F, 0x22, 0xC0 } // mov cr0, eax

// ============================================================
// STEP 11: Far jump to 32-bit code
// ============================================================
// jmp 0x08:entry_32bit
far_jump(0x08, 0x8000)   // Will be patched - placeholder

// ============================================================
// 32-BIT COMPATIBILITY MODE ENTRY
// ============================================================
label entry_32bit:
// Set data segments to 0x10 (data32)
raw { 0xB8, 0x10, 0x00, 0x00, 0x00 } // mov eax, 0x10
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x8E, 0xD0 }       // mov ss, ax

// Copy kernel: 3 chunks from bounce buffers to 0x100000
// Chunk 1: 0x20000 → 0x100000
raw { 0xBE, 0x00, 0x00, 0x02, 0x00 } // mov esi, 0x20000
raw { 0xBF, 0x00, 0x00, 0x10, 0x00 } // mov edi, 0x100000
raw { 0xB9, 0x80, 0x3F, 0x00, 0x00 } // mov ecx, 0x3F80
raw { 0xF3, 0xA5 }       // rep movsd

// Chunk 2: 0x40000 → 0x10FE00
raw { 0xBE, 0x00, 0x00, 0x04, 0x00 } // mov esi, 0x40000
raw { 0xBF, 0x00, 0xFE, 0x10, 0x00 } // mov edi, 0x10FE00
raw { 0xB9, 0x80, 0x3F, 0x00, 0x00 } // mov ecx, 0x3F80
raw { 0xF3, 0xA5 }       // rep movsd

// Chunk 3: 0x60000 → 0x11FC00
raw { 0xBE, 0x00, 0x00, 0x06, 0x00 } // mov esi, 0x60000
raw { 0xBF, 0x00, 0xFC, 0x11, 0x00 } // mov edi, 0x11FC00
raw { 0xB9, 0x80, 0x3F, 0x00, 0x00 } // mov ecx, 0x3F80
raw { 0xF3, 0xA5 }       // rep movsd

// Far jump to 64-bit code
far_jump(0x18, 0x8000)   // Will be patched - placeholder

// ============================================================
// 64-BIT LONG MODE ENTRY
// ============================================================
label entry_64bit:
// Set up 64-bit data segments
raw { 0x66, 0xB8, 0x20, 0x00 } // mov ax, 0x20
raw { 0x8E, 0xD8 }       // mov ds, ax
raw { 0x8E, 0xC0 }       // mov es, ax
raw { 0x8E, 0xD0 }       // mov ss, ax
raw { 0x8E, 0xE0 }       // mov fs, ax
raw { 0x8E, 0xE8 }       // mov gs, ax

// Set up 64-bit stack at 0x200000
raw { 0x48, 0xBC, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00 } // mov rsp, 0x200000

// Jump to kernel at 0x100000
raw { 0x48, 0xB8, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00 } // mov rax, 0x100000
raw { 0xFF, 0xE0 } // jmp rax

// Halt if kernel returns
label halt_loop:
cli
hlt
jmp halt_loop
